<html>
<head>
  <title>Semantic Web Application Platform</title>
  <meta http-equiv="Content-Type" content="text/html">
  <link href="/SyleSheets/base.css" rel="stylesheet" type="text/css">
  <link href="/StyleSheets/base.css" rel="stylesheet" type="text/css">
</head>

<body>
<p><a href="/">W3C </a>| <a href="/2000/01/sw/Overview.html">Semantic
Web</a></p>

<p>Related:</p>
<ul>
  <li><a href="/DesignIssues/Notation3.html">Notation3 in Design
  Issues</a></li>
</ul>

<p></p>

<h1>Semantic Web Area for Play</h1>

<p></p>

<p>or, if you like, <em>Semantic Web Application Platform</em>...  visiting
RDF and all points west.</p>

<h2 id="Motivation">Motivation</h2>

<p>These are a few things I put together to</p>
<ul>
  <li>Resolve the fact that I had no code development environment</li>
  <li>Check out python</li>
  <li>Investigate the questions of the real RDF model particularly with
    respect to
    <ul>
      <li>alternative quick scribbling (wiki wiki?) syntax - notation3</li>
      <li>managing several bags of RDF data, not covered by the RDF spec</li>
      <li>relationships between this and rule languages</li>
    </ul>
  </li>
</ul>

<p></p>

<p>The bits are now as follows. There is NO guarantee or support or anything
for these.</p>

<h2 id="Python">Python modules</h2>

<h3 id="L133">Serializing/deserializaing RDF: notation3.py</h3>

<p>Originally written by Dan Connolly, uses a basic RDF stream parser
interface</p>
<ul>
  <li>Parses N3</li>
  <li>Generates RDF</li>
  <li>Generates N3</li>
</ul>

<p>The command line form  (alias n3 python notation3.py; n3 -help) allows RDF
to be parsed and re-output.</p>

<p>The module will also run as a CGI script to convert N3 to RDF M&amp;S 1.0 -
by DanC magic.</p>
<ul>
  <li><a href="notation3.py">Source</a></li>
</ul>

<p></p>

<h3 id="L311">xml2rdf.py   Parsing RDF</h3>

<p>Based on Python's xmllib, this parser is ocmpatible with the RDF stream
interface of, notation3.py.  It completes the square of parsers and
generators.</p>
<ul>
  <li>Parses RDF</li>
</ul>

<p>It has a command line mode for self-test purposes.</p>
<ul>
  <li><a href="xml2rdf.py">Source</a></li>
</ul>

<p></p>

<h3 id="Closed">Closed World Machine : cwm.py</h3>

<p>(pronounced roughly: coom as in room) This is a triple store, in which
triples are stored in/against the particular context in which they were read,
eg RDF file or N3 { expression }. The features at the moment include</p>
<ul>
  <li>Loading files in RDF and/or N3</li>
  <li>Applying rules written in N3 to the data.</li>
  <li>Filtering the data to the result of a particular query</li>
  <li>Generating RDF or N3 files from the result.</li>
  <li>Pretty printing data so that anonymous nodes are used creatively to
    minimize the number of explicit existentials (generated Ids).</li>
</ul>

<p></p>

<p>Cwm will run as a unix command, and is designed to be usable as a simple
data manipulator for RDF on the lines of sed, awk, etc or xsl.</p>

<p>In progress.</p>
<ul>
  <li><a href="cwm.py">Source</a></li>
</ul>

<h4 id="Command">Command line parameters</h4>
<dl>
  <dt>-help</dt>
    <dd>generate a maybe more up to date list of parameters</dd>
  <dt>-pipe</dt>
    <dd>don't store, just process serially. (doesn't lose comment lines!)</dd>
  <dt>-rdf</dt>
    <dd>input format RDF format from now on</dd>
  <dt>-rdf1out</dt>
    <dd>output format is RDF.</dd>
  <dt><em>URI</em></dt>
    <dd>load the resource. Parsed relative to the local directory, so a
      filename will work.</dd>
  <dt>-size</dt>
    <dd>Output the current size of the store.</dd>
  <dt>-apply=<em>uri</em></dt>
    <dd>Apply the rules in a given resource, once each, to the store, the
      conclusions being added to the store.</dd>
  <dt>-filter=<em>uri</em></dt>
    <dd>Apply the rules in a given resource, once each, to the store,
      replacing the original contents of the store with those things concluded
      from the rules.</dd>
  <dt>-rules</dt>
    <dd>Apply any rules in the store to the store itself, conclusions being
      added to the store.</dd>
  <dt>-ugly</dt>
    <dd>Dump the store in a more or less random order. This tends to be messy,
      as related information is not grouped.</dd>
  <dt>-bySubject</dt>
    <dd>Dump the store grouping statements by subject. This tends to be better
      than -ugly, but the default is to make the output as readable as
      possible using anonymous nodes wherever possible, and is therefore
      recommended.</dd>
</dl>

<p>-bySubject</p>

<p></p>

<p></p>

<h2>Design issues</h2>

<p>The code above investigated and raised issues discussed in the following
documents.</p>
<ul>
  <li>Notation 3 - an alternative RDF syntax</li>
  <li>Quantification implicit in anonymous nodes</li>
</ul>
<hr>

<p></p>

<p>Tim BL</p>

<p>$Id$</p>
</body>
</html>
