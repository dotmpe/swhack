#
# Baccus - Naur Form (BNF) vocabulary
#

@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>.
@prefix bnf: <http://www.w3.org/2000/10/swap/grammar/bnf#>.
@prefix : <http://www.w3.org/2000/10/swap/grammar/bnf-rules#>.
@prefix rul: <http://www.w3.org/2000/10/swap/grammar/bnf-rules#>.
@prefix n3: <http://www.w3.org/2000/10/swap/grammar/n3#>.
@prefix list: <http://www.w3.org/2000/10/swap/list#>.
@prefix doc: <http://www.w3.org/2000/10/swap/pim/doc#>.
@prefix log: <http://www.w3.org/2000/10/swap/log#>.
@prefix string: <http://www.w3.org/2000/10/swap/string#>.
@keywords a, is, of.

#_____________________________________

# Shorthand expansion into BNF

{ ?x bnf:zeroOrMore ?y } => {
    ?x bnf:mustBeOneSequence (
		( void )
		( ?y ?x )
	) 
}.

{ ?x bnf:mustBe ?y } => {?x bnf:mustBeOneSequence ((?y))}.

# Axioms relating the definite (open world) form to the indefinte (closed world) 
#(better words?) form:

{ ?x bnf:mustBe ?y } => { ?x bnf:mustBeOneSequence (( ?y )) }.

{ ?x bnf:mustBeOneSequence ?y} => { ?x optionTail ?y }.

{?x optionTail [rdf:first ?y; rdf:rest ?z]} => {
	?x 	bnf:canBeSequence ?y;
		optionTail ?z.
	?y a :Used}.

{ ?x bnf:canBeSequence ?y } =>  { ?y sequenceTail ?y }.

{ ?x sequenceTail [ rdf:rest ?z ] } => { ?x sequenceTail ?z }.

{ ?x sequenceTail [ rdf:first ?y; rdf:rest [ rdf:first ?z ]] } =>
	{?y canPrecede ?z}.

# Have to separatethe next two rules 
{ ?x bnf:canBeSequence [ rdf:first ?y ].
  ?y log:rawType log:Literal. }  => { ?x bnf:canStartWithLiteral ?y }.

{ ?x bnf:canStartWithLiteral ?y .
  (?y "(.).*")  string:scrape ?c }  => { ?x bnf:canStartWith ?c }.

#______________________________________________________________



# Rules for determining branching

{ 	?x bnf:canBeSequence ?s. ?s rdf:first [bnf:canStartWith ?y].
} => {
	?x bnf:selector ( ?y ?s ); bnf:canStartWith ?y.
}.


{   	?x a Used; bnf:canBeSequence ?s.
} => {
	?y a Used.
	?s a UsedSequence.
	?s a UsedTail.
}.


# { ?y list:in [a UsedSequence].} => {?y a Used}.

#{ ?s a UsedTail; rdf:first ?x; rdf:rest ?r } => {?r a UsedTail}.

#{ ?s a UsedTail; rdf:first ?x; rdf:rest [ rdf:first ?y ] } => { ?x canPrecede ?y }.

{ ?x bnf:canBeSequence [ list:last ?y ]; canPrecede ?z} => { ?y canPrecede ?z }.



#ends
