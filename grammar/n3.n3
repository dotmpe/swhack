# Notation3 
# BNF without tokenization
#
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>.
@prefix bnf: <http://www.w3.org/2000/10/swap/grammar/bnf#>.
@prefix rul: <http://www.w3.org/2000/10/swap/grammar/bnf-rules#>.
@prefix : <http://www.w3.org/2000/10/swap/grammar/n3#>.
@prefix n3: <http://www.w3.org/2000/10/swap/grammar/n3#>.
@prefix list: <http://www.w3.org/2000/10/swap/list#>.
@prefix string: <http://www.w3.org/2000/10/swap/string#>.
@keywords a, is, of.


<> bnf:syntaxFor [ bnf:internetMediaType 
		<http://www.w3.org/2003/mediatypes#application/n3>].

# <> rdfsem:semanticsFor ""   .....

# The N3 Full Grammar

n3document a rul:Used;
	bnf:mustBeOneSequence(
	
		( bnf:void ) 
		(
			[ bnf:zeroOrMore declaration ]
			[ bnf:zeroOrMore  universal ]
			[ bnf:zeroOrMore existential ]
			[ bnf:zeroOrMore [ bnf:mustBeOneSequence((statement period)) ] ]
		)
	).

formulacontent bnf:mustBeOneSequence ((
		[ bnf:zeroOrMore declaration ]
		[ bnf:zeroOrMore  universal ]
		[ bnf:zeroOrMore existential ]
		statementlist
	)).


statementlist bnf:mustBeOneSequence (
		( bnf:void )
		( statement statementtail )
	).

statementtail bnf:mustBeOneSequence (
		( bnf:void)
		( period statementlist )
	).

universal bnf:mustBeOneSequence (
		(
			"@forAll"
			[ bnf:commaSeparatedPeriodTerminatedListOf symbol ]
		)).

existential bnf:mustBeOneSequence(
		(	 "@forSome" 
			 [ bnf:commaSeparatedPeriodTerminatedListOf symbol ]
		)).


symbol bnf:mustBeOneSequence (
		(explicituri)
		(qname)
	).

qname bnf:mustBeOneSequence(
		( prefix colon localname )
		( localname )
	).

declaration bnf:mustBeOneSequence(
		( "@prefix" qname explicituri period )
		( "@keywords" [ bnf:commaSeparatedPeriodTerminatedListOf barename ] )
	).


statement bnf:mustBeOneSequence(( subject propertylist )).


propertylist bnf:mustBeOneSequence (
		( bnf:void )
		( verb objectlist propertylisttail )
	).

propertylisttail bnf:mustBeOneSequence (
		( bnf:void )
		( semicolon propertylist )
	).

objectlist bnf:mustBeOneSequence (
		( object  [ bnf:zeroOrMore [ 
				bnf:mustBeOneSequence (
					( comma )
					( objectlist )
				) ]
			  ] )).


verb bnf:mustBeOneSequence (
		( prop )
		( "@has" prop )
		( "@is" prop "@of" )
		( "@a" )
		( "=" )
		( "=>" )
		( "<=" ) 
	).

prop bnf:mustBeOneSequence ((node)).

subject bnf:mustBeOneSequence ((item)).

object bnf:mustBeOneSequence ((item)).

item bnf:mustBeOneSequence(
		(path)
#		( node "@of" path )     # Not implemented, just an idea
	).


path bnf:mustBeOneSequence(
		( node pathtail )
	).

pathtail bnf:mustBeOneSequence(
		( bnf:void )
		( traverse path )
		( uparrow path )
	).


node bnf:mustBeOneSequence (
		(symbol)
		(anonnode)
		(variable)
		(numericliteral)
		(string)
		("@this")	  #  Deprocated.  Was allowed for this log:forAll x
).

anonnode bnf:mustBeOneSequence (
		( "[" propertylist "]"  )
		( "{" formulacontent "}" )
		(  "("  itemlist ")"  )
	).

itemlist bnf:zeroOrMore item.
 
prefix bnf:mustBeOneSequence (
		( alphanumeric )
		( "_" )
	).

#   TOKENS

alphanumeric 	bnf:matches  	"[a-zA-Z][a-zA-Z0-9_]*";
		bnf:canStartWith	"a".

numericliteral	bnf:matches	"""[-+]?[0-9]+(\\.[0-9]+)?(e[-+]?[0-9]+)?""";
		bnf:canStartWith 	"0", "-", "+".

explicituri 	bnf:matches 	"<[^>].*>";
		bnf:canStartWith 	"<".

qname 		bnf:matches  	"(([a-zA-Z_][a-zA-Z0-9_]*)?:)?([a-zA-Z_][a-zA-Z0-9_]*)?";
		bnf:canStartWith 	"a", "_".  # @@ etc

barename 	bnf:matches  	"[a-zA-Z_][a-zA-Z0-9_]*";  # subset of qname
		bnf:canStartWith 	"a", "_".  # @@ etc

variable 	bnf:matches  	"\\?[a-zA-Z_][a-zA-Z0-9_]*";  # ? barename
		bnf:canStartWith 	"?".  #

langcode	bnf:matches  	"[a-zA-Z0-9]+(-[a-zA-Z0-9]+)?";
		bnf:canStartWith 	"a".

traverse	bnf:matches		"!";
		bnf:canStartWith	"!".

uparrow		bnf:mustBeOneSequence (( "^"));
		bnf:canStartWith	"^".

semicolon	bnf:mustBeOneSequence (( ";"));
		bnf:canStartWith	";".

comma		bnf:mustBeOneSequence (( ","));
		bnf:canStartWith	",".

period		bnf:mustBeOneSequence (( "."));
		bnf:canStartWith	".".

#               raw regexp single quoted would be   "([^"]|(\\"))*"
# @@@ triple-quoted version too

string		bnf:matches		"""("([^"]|(\\\\"))*")""".

#____________________________________________________

#  Axioms reducing the shortcut BNF terms to bnf:musBeOneSequence.

{ ?x bnf:zeroOrMore ?y } => {
    ?x bnf:mustBeOneSequence (
		( bnf:void )
		( ?y ?x )
	) 
}.


{ ?x bnf:commaSeparatedPeriodTerminatedListOf ?y } =>
{
	?x bnf:mustBeOneSequence (
		( period )
		( comma ?y ?x )
	)
}.


#  labelling of things which do not have explicit URIs:

{ ?x bnf:zeroOrMore [ bnf:label ?y].
	( ?y "_s" ) string:concatenation ?str } => { ?x bnf:label ?str }.

{ ?x bnf:commaSeparatedPeriodTerminatedListOf [ bnf:label ?y].
	( ?y "_csl" ) string:concatenation ?str } => { ?x bnf:label ?str }.


#ends
