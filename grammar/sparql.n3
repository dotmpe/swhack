#SPARQL in Notation3
# Context Free Grammar without tokenization
#
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>.
@prefix cfg: <http://www.w3.org/2000/10/swap/grammar/bnf#>.
@prefix rul: <http://www.w3.org/2000/10/swap/grammar/bnf-rules#>.
@prefix : <http://www.w3.org/2000/10/swap/grammar/sparql#>.
@prefix n3: <http://www.w3.org/2000/10/swap/grammar/n3#>.
@prefix list: <http://www.w3.org/2000/10/swap/list#>.
@prefix string: <http://www.w3.org/2000/10/swap/string#>.
@keywords a, is, of.

    Query cfg:mustBeOneSequence ( 
           ( Prolog [ cfg:mustBeOneSequence ( 
             ( SelectQuery  ) 
             ( ConstructQuery  ) 
             ( DescribeQuery  ) 
             ( AskQuery  ) 
           )  ] ) 
         ) . 

SelectQuery cfg:mustBeOneSequence ( 
           ( "SELECT" [ 
           cfg:mustBeOneSequence ( () (  "DISTINCT"  ) ) ][ cfg:mustBeOneSequence ( 
             ( Var [ 
             cfg:zeroOrMore  Var  ] ) 
             ( "*"  ) 
           )  ] DatasetClause  WherePattern  ResultsFilter  ) 
         ) . 

ConstructQuery cfg:mustBeOneSequence ( 
           ( "CONSTRUCT"  ConstructTemplate  DatasetClause  WherePattern  ResultsFilter  ) 
         ) . 

DescribeQuery cfg:mustBeOneSequence ( 
           ( "DESCRIBE" [ cfg:mustBeOneSequence ( 
             ( VarOrIRIref [ 
             cfg:zeroOrMore  VarOrIRIref  ] ) 
             ( "*"  ) 
           )  ] DatasetClause [ 
           cfg:mustBeOneSequence ( () (  WherePattern  ) ) ] ResultsFilter  ) 
         ) . 

AskQuery cfg:mustBeOneSequence ( 
           ( "ASK"  DatasetClause [ 
           cfg:mustBeOneSequence ( () (  WherePattern  ) ) ] ) 
         ) . 

Prolog cfg:mustBeOneSequence ( 
           ([ 
           cfg:mustBeOneSequence ( () (  BaseDecl  ) ) ][ 
           cfg:zeroOrMore  PrefixDecl  ] ) 
         ) . 

BaseDecl cfg:mustBeOneSequence ( 
           ( "BASE"  QuotedIRIref  ) 
         ) . 

PrefixDecl cfg:mustBeOneSequence ( 
           ( "PREFIX"  QNAME_NS  QuotedIRIref  ) 
         ) . 

DatasetClause cfg:mustBeOneSequence ( 
           ([ 
           cfg:mustBeOneSequence ( () (  DefaultGraphClause  ) ) ][ 
           cfg:zeroOrMore  NamedGraphClause  ] ) 
         ) . 

DefaultGraphClause cfg:mustBeOneSequence ( 
           ( "FROM"  SourceSelector  ) 
         ) . 

NamedGraphClause cfg:mustBeOneSequence ( 
           ( FROM_NAMED  SourceSelector  ) 
         ) . 

SourceSelector cfg:mustBeOneSequence ( 
           ( IRIref  ) 
         ) . 

WherePattern cfg:mustBeOneSequence ( 
           ([ 
           cfg:mustBeOneSequence ( () (  "WHERE"  ) ) ][ cfg:mustBeOneSequence ( 
             ( EmptyPattern  ) 
             ( GraphPattern  ) 
           )  ] ) 
         ) . 

GraphPattern cfg:mustBeOneSequence ( 
           ( "{"  Union  "}"  ) 
         ) . 

ConstructTemplate cfg:mustBeOneSequence ( 
           ( "{"  SubjectStatements [ cfg:mustBeOneSequence ( 
             ( "."  SubjectStatements  ) 
           )  ] "}"  ) 
         ) . 

ResultsFilter cfg:mustBeOneSequence ( 
           ([ 
           cfg:mustBeOneSequence ( () (  OrderClause  ) ) ][ 
           cfg:mustBeOneSequence ( () (  LimitClause  ) ) ][ 
           cfg:mustBeOneSequence ( () (  OffsetClause  ) ) ] ) 
         ) . 

OrderClause cfg:mustBeOneSequence ( 
           ( "ORDER"  "BY"  OrderCondition [ 
           cfg:zeroOrMore  OrderCondition  ] ) 
         ) . 

OrderCondition cfg:mustBeOneSequence ( 
           ([ cfg:mustBeOneSequence ( 
             ( "ASC"  ) 
             ( "DESC"  ) 
           )  ] "("  Expression  ")"  ) 
           ( FunctionCall  ) 
           ( Var  ) 
           ( "("  Expression  ")"  ) 
         ) . 

LimitClause cfg:mustBeOneSequence ( 
           ( "LIMIT"  INTEGER  ) 
         ) . 

OffsetClause cfg:mustBeOneSequence ( 
           ( "OFFSET"  INTEGER  ) 
         ) . 

Union cfg:mustBeOneSequence ( 
           ( Pattern  "UNION"  Union  ) 
           ( Pattern  ) 
         ) . 

Optional cfg:mustBeOneSequence ( 
           ( "OPTIONAL"  PatternElts  ) 
         ) . 

GraphConstraint cfg:mustBeOneSequence ( 
           ( "GRAPH"  VarOrBlankNodeOrIRIref  PatternElts  ) 
         ) . 

Pattern cfg:mustBeOneSequence ( 
           ( SubjectStatements [ 
           cfg:zeroOrMore  AfterSubjectStatements  ][ 
           cfg:mustBeOneSequence ( () (  TrailingDot  ) ) ] ) 
           ( NonSubjectPatternStarters [ 
           cfg:zeroOrMore  AfterNotSubject  ][ 
           cfg:mustBeOneSequence ( () (  TrailingDot  ) ) ] ) 
         ) . 

AfterSubjectStatements cfg:mustBeOneSequence ( 
           ( "."  SubjectStatements  ) 
           ([ 
           cfg:mustBeOneSequence ( () (  TrailingDot  ) ) ] NonSubjectPatternElts  ) 
         ) . 

AfterNotSubject cfg:mustBeOneSequence ( 
           ([ 
           cfg:mustBeOneSequence ( () (  "."  ) ) ] SubjectStatements  ) 
           ([ 
           cfg:mustBeOneSequence ( () (  TrailingDot  ) ) ] NonSubjectPatternElts  ) 
         ) . 

NonSubjectPatternStarters cfg:mustBeOneSequence ( 
           ( Optional  ) 
           ( GraphConstraint  ) 
           ( GraphPattern  ) 
         ) . 

NonSubjectPatternElts cfg:mustBeOneSequence ( 
           ( NonSubjectPatternStarters  ) 
           ( Filter  ) 
         ) . 

PatternElts cfg:mustBeOneSequence ( 
           ( NonSubjectPatternStarters  ) 
           ( Filter  ) 
         ) . 

Filter cfg:mustBeOneSequence ( 
           ( "FILTER"  "("  Expression  ")"  ) 
         ) . 

SubjectStatements cfg:mustBeOneSequence ( 
           ( Subject [ 
           cfg:mustBeOneSequence ( () (  PredicateObjectList  ) ) ] ) 
         ) . 

PredicateObjectList cfg:mustBeOneSequence ( 
           ( Predicate  ObjectList [ cfg:mustBeOneSequence ( 
             ( ";"  Predicate  ObjectList  ) 
           )  ] ) 
         ) . 

ObjectList cfg:mustBeOneSequence ( 
           ( Object [ cfg:mustBeOneSequence ( 
             ( ","  Object  ) 
           )  ] ) 
         ) . 

Subject cfg:mustBeOneSequence ( 
           ( GraphNode  ) 
         ) . 

Predicate cfg:mustBeOneSequence ( 
           ( VarOrBlankNodeOrIRIref  ) 
           ( "a"  ) 
         ) . 

Object cfg:mustBeOneSequence ( 
           ( VarOrTerm  ) 
           ( TriplesNode  ) 
         ) . 

TriplesNode cfg:mustBeOneSequence ( 
           ( Collection  ) 
           ( BlankNodePropertyList  ) 
         ) . 

BlankNodePropertyList cfg:mustBeOneSequence ( 
           ( "["  PredicateObjectList  "]"  ) 
         ) . 

Collection cfg:mustBeOneSequence ( 
           ( "("  GraphNode [ 
           cfg:zeroOrMore  GraphNode  ] ")"  ) 
         ) . 

GraphNode cfg:mustBeOneSequence ( 
           ( VarOrTerm  ) 
           ( TriplesNode  ) 
         ) . 

VarOrTerm cfg:mustBeOneSequence ( 
           ( Var  ) 
           ( GraphTerm  ) 
         ) . 

VarOrIRIref cfg:mustBeOneSequence ( 
           ( Var  ) 
           ( IRIref  ) 
         ) . 

VarOrBlankNodeOrIRIref cfg:mustBeOneSequence ( 
           ( Var  ) 
           ( BlankNode  ) 
           ( IRIref  ) 
         ) . 

Var cfg:mustBeOneSequence ( 
           ( VAR1  ) 
           ( VAR2  ) 
         ) . 

GraphTerm cfg:mustBeOneSequence ( 
           ( RDFTerm  ) 
           ( "("  ")"  ) 
         ) . 

Expression cfg:mustBeOneSequence ( 
           ( ConditionalOrExpression  ) 
         ) . 

ConditionalOrExpression cfg:mustBeOneSequence ( 
           ( ConditionalAndExpression [ cfg:mustBeOneSequence ( 
             ( "||"  ConditionalAndExpression  ) 
           )  ] ) 
         ) . 

ConditionalAndExpression cfg:mustBeOneSequence ( 
           ( ValueLogical [ cfg:mustBeOneSequence ( 
             ( "&&"  ValueLogical  ) 
           )  ] ) 
         ) . 

ValueLogical cfg:mustBeOneSequence ( 
           ( RelationalExpression  ) 
         ) . 

RelationalExpression cfg:mustBeOneSequence ( 
           ( NumericExpression [ cfg:mustBeOneSequence ( 
             ( "="  NumericExpression  ) 
             ( "!="  NumericExpression  ) 
             ( "<"  NumericExpression  ) 
             ( ">"  NumericExpression  ) 
             ( "<="  NumericExpression  ) 
             ( ">="  NumericExpression  ) 
           )  ] ) 
         ) . 

NumericExpression cfg:mustBeOneSequence ( 
           ( AdditiveExpression  ) 
         ) . 

AdditiveExpression cfg:mustBeOneSequence ( 
           ( MultiplicativeExpression [ cfg:mustBeOneSequence ( 
             ( "+"  MultiplicativeExpression  ) 
             ( "-"  MultiplicativeExpression  ) 
           )  ] ) 
         ) . 

MultiplicativeExpression cfg:mustBeOneSequence ( 
           ( UnaryExpression [ cfg:mustBeOneSequence ( 
             ( "*"  UnaryExpression  ) 
             ( "/"  UnaryExpression  ) 
           )  ] ) 
         ) . 

UnaryExpression cfg:mustBeOneSequence ( 
           ( "!"  CallExpression  ) 
           ( "+"  CallExpression  ) 
           ( "-"  CallExpression  ) 
           ( CallExpression  ) 
         ) . 

CallExpression cfg:mustBeOneSequence ( 
           ( "STR"  "("  Expression  ")"  ) 
           ( "LANG"  "("  Expression  ")"  ) 
           ( "DATATYPE"  "("  Expression  ")"  ) 
           ( "REGEX"  "("  Expression  ","  String [ cfg:mustBeOneSequence ( 
             ( ","  String  ) 
           )  ] ")"  ) 
           ( "BOUND"  "("  Var  ")"  ) 
           ( "isURI"  "("  Expression  ")"  ) 
           ( "isBLANK"  "("  Expression  ")"  ) 
           ( "isLITERAL"  "("  Expression  ")"  ) 
           ( FunctionCall  ) 
           ( PrimaryExpression  ) 
         ) . 

PrimaryExpression cfg:mustBeOneSequence ( 
           ([ cfg:mustBeOneSequence ( 
             ( Var  ) 
             ( RDFTerm  ) 
             ( "("  Expression  ")"  ) 
           )  ] ) 
         ) . 

FunctionCall cfg:mustBeOneSequence ( 
           ( IRIref  ArgList  ) 
         ) . 

ArgList cfg:mustBeOneSequence ( 
           ( "(" [ cfg:mustBeOneSequence ( 
             ( Expression [ cfg:mustBeOneSequence ( 
               ( ","  Expression  ) 
             )  ] ) 
           )  ] ")"  ) 
         ) . 

RDFTerm cfg:mustBeOneSequence ( 
           ( IRIref  ) 
           ( RDFLiteral  ) 
           ( NumericLiteral  ) 
           ( BooleanLiteral  ) 
           ( BlankNode  ) 
         ) . 

NumericLiteral cfg:mustBeOneSequence ( 
           ( INTEGER  ) 
           ( FLOATING_POINT  ) 
         ) . 

RDFLiteral cfg:mustBeOneSequence ( 
           ( String [ cfg:mustBeOneSequence ( 
             ([ cfg:mustBeOneSequence ( 
               ( LANGTAG  ) 
             )  ] ) 
             ([ cfg:mustBeOneSequence ( 
               ( "^^"  IRIref  ) 
             )  ] ) 
           )  ] ) 
         ) . 

BooleanLiteral cfg:mustBeOneSequence ( 
           ( "true"  ) 
           ( "false"  ) 
         ) . 

String cfg:mustBeOneSequence ( 
           ( STRING_LITERAL1  ) 
           ( STRING_LITERAL2  ) 
           ( STRING_LITERAL_LONG1  ) 
           ( STRING_LITERAL_LONG2  ) 
         ) . 

IRIref cfg:mustBeOneSequence ( 
           ( QuotedIRIref  ) 
           ( QName  ) 
         ) . 

QName cfg:mustBeOneSequence ( 
           ( QNAME  ) 
           ( QNAME_NS  ) 
         ) . 

BlankNode cfg:mustBeOneSequence ( 
           ( BNODE_LABEL  ) 
           ( "["  "]"  ) 
         ) . 
###
# terminals
###

EmptyPattern	cfg:matches	"\\{[ \\t\\r\\n]*\\}";
		cfg:canStartWith   "{" . 
TrailingDot	cfg:matches	"\\.(?=((?:[ \\t\\r\\n]*(?:(?:\\})|(?:(?:(?:(?:(?:UNION)|(?:OPTIONAL))|(?:GRAPH))|(?:FILTER))[^a-zA-Z])))))";
		cfg:canStartWith   "." . 
FROM_NAMED	cfg:matches	"FROM[ \\t\\r\\n]+NAMED";
		cfg:canStartWith   "FROM" . 
QuotedIRIref	cfg:matches	"<[^> ]*>";
		cfg:canStartWith   "<" . 
INTEGER	cfg:matches	"[0-9]+";
		cfg:canStartWith   "0" . 
DECIMAL	cfg:matches	"(?:[0-9]+\\.[0-9]*)|(?:\\.[0-9]+)";
		cfg:canStartWith   "0" . 
#EXPONENT	cfg:matches	"[eE][\\+-]?[0-9]+";
#		cfg:canStartWith   "" . 
FLOATING_POINT	cfg:matches	"(?:(?:[0-9]+\\.[0-9]*(?:[eE][\\+-]?[0-9]+)?)|(?:\\.[0-9]+(?:[eE][\\+-]?[0-9]+)?))|(?:[0-9]+(?:[eE][\\+-]?[0-9]+))";
		cfg:canStartWith   "0" . 
STRING_LITERAL1	cfg:matches	"'(?:(?:[^'\\\\\\n\\r])|(?:(?:\\\\\\\\[^\\n\\r])))*'";
		cfg:canStartWith   "'" . 
STRING_LITERAL2	cfg:matches	"\"(?:(?:[^\"\\\\\\n\\r])|(?:(?:\\\\\\\\[^\\n\\r])))*\"";
		cfg:canStartWith   "\"" . 
STRING_LITERAL_LONG1	cfg:matches	"\"\"\"(?:(?:(?:(?:[^\"\\\\])|(?:(?:\\\\[^\\n\\r])))|(?:(?:\"[^\"])))|(?:(?:\"\"[^\"])))*\"\"\"";
		cfg:canStartWith   "\"\"\"" . 
STRING_LITERAL_LONG2	cfg:matches	"'''(?:(?:(?:(?:[^'\\\\])|(?:(?:\\\\[^\\n\\r])))|(?:(?:'[^'])))|(?:(?:''[^'])))*'''";
		cfg:canStartWith   "'''" . 
LANGTAG	cfg:matches	"@[a-zA-Z]+(?:-[a-zA-Z0-9]+)*";
		cfg:canStartWith   "@" . 
#NCCHAR1	cfg:matches	"(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:[A-Z])|(?:[a-z]))|(?:[\u00C0-\u00D6]))|(?:[\u00D8-\u00F6]))|(?:[\u00F8-\u02FF]))|(?:[\u0370-\u037D]))|(?:[\u037F-\u1FFF]))|(?:[\u200C-\u200D]))|(?:[\u2070-\u218F]))|(?:[\u2C00-\u2FEF]))|(?:[\u3001-\uD7FF]))|(?:[\uF900-\uFFFE])";
#		cfg:canStartWith   "" . 
#NCCHAR	cfg:matches	"(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:[A-Z])|(?:[a-z]))|(?:[\u00C0-\u00D6]))|(?:[\u00D8-\u00F6]))|(?:[\u00F8-\u02FF]))|(?:[\u0370-\u037D]))|(?:[\u037F-\u1FFF]))|(?:[\u200C-\u200D]))|(?:[\u2070-\u218F]))|(?:[\u2C00-\u2FEF]))|(?:[\u3001-\uD7FF]))|(?:[\uF900-\uFFFE])))|(?:_))|(?:-))|(?:\\.))|(?:[0-9]))|(?:\u00B7)";
#		cfg:canStartWith   "" . 
#NCNAME_PREFIX	cfg:matches	"(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:[A-Z])|(?:[a-z]))|(?:[\u00C0-\u00D6]))|(?:[\u00D8-\u00F6]))|(?:[\u00F8-\u02FF]))|(?:[\u0370-\u037D]))|(?:[\u037F-\u1FFF]))|(?:[\u200C-\u200D]))|(?:[\u2070-\u218F]))|(?:[\u2C00-\u2FEF]))|(?:[\u3001-\uD7FF]))|(?:[\uF900-\uFFFE]))(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:[A-Z])|(?:[a-z]))|(?:[\u00C0-\u00D6]))|(?:[\u00D8-\u00F6]))|(?:[\u00F8-\u02FF]))|(?:[\u0370-\u037D]))|(?:[\u037F-\u1FFF]))|(?:[\u200C-\u200D]))|(?:[\u2070-\u218F]))|(?:[\u2C00-\u2FEF]))|(?:[\u3001-\uD7FF]))|(?:[\uF900-\uFFFE])))|(?:_))|(?:-))|(?:\\.))|(?:[0-9]))|(?:\u00B7))*";
#		cfg:canStartWith   "" . 
QNAME_NS	cfg:matches	"(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:[A-Z])|(?:[a-z]))|(?:[\u00C0-\u00D6]))|(?:[\u00D8-\u00F6]))|(?:[\u00F8-\u02FF]))|(?:[\u0370-\u037D]))|(?:[\u037F-\u1FFF]))|(?:[\u200C-\u200D]))|(?:[\u2070-\u218F]))|(?:[\u2C00-\u2FEF]))|(?:[\u3001-\uD7FF]))|(?:[\uF900-\uFFFE]))(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:[A-Z])|(?:[a-z]))|(?:[\u00C0-\u00D6]))|(?:[\u00D8-\u00F6]))|(?:[\u00F8-\u02FF]))|(?:[\u0370-\u037D]))|(?:[\u037F-\u1FFF]))|(?:[\u200C-\u200D]))|(?:[\u2070-\u218F]))|(?:[\u2C00-\u2FEF]))|(?:[\u3001-\uD7FF]))|(?:[\uF900-\uFFFE])))|(?:_))|(?:-))|(?:\\.))|(?:[0-9]))|(?:\u00B7))*)?:";
		cfg:canStartWith   "a" . 
#NCNAME	cfg:matches	"(?:(?:_)|(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:[A-Z])|(?:[a-z]))|(?:[\u00C0-\u00D6]))|(?:[\u00D8-\u00F6]))|(?:[\u00F8-\u02FF]))|(?:[\u0370-\u037D]))|(?:[\u037F-\u1FFF]))|(?:[\u200C-\u200D]))|(?:[\u2070-\u218F]))|(?:[\u2C00-\u2FEF]))|(?:[\u3001-\uD7FF]))|(?:[\uF900-\uFFFE]))))(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:[A-Z])|(?:[a-z]))|(?:[\u00C0-\u00D6]))|(?:[\u00D8-\u00F6]))|(?:[\u00F8-\u02FF]))|(?:[\u0370-\u037D]))|(?:[\u037F-\u1FFF]))|(?:[\u200C-\u200D]))|(?:[\u2070-\u218F]))|(?:[\u2C00-\u2FEF]))|(?:[\u3001-\uD7FF]))|(?:[\uF900-\uFFFE])))|(?:_))|(?:-))|(?:\\.))|(?:[0-9]))|(?:\u00B7))*";
#		cfg:canStartWith   "" . 
BNODE_LABEL	cfg:matches	"_:(?:(?:(?:_)|(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:[A-Z])|(?:[a-z]))|(?:[\u00C0-\u00D6]))|(?:[\u00D8-\u00F6]))|(?:[\u00F8-\u02FF]))|(?:[\u0370-\u037D]))|(?:[\u037F-\u1FFF]))|(?:[\u200C-\u200D]))|(?:[\u2070-\u218F]))|(?:[\u2C00-\u2FEF]))|(?:[\u3001-\uD7FF]))|(?:[\uF900-\uFFFE]))))(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:[A-Z])|(?:[a-z]))|(?:[\u00C0-\u00D6]))|(?:[\u00D8-\u00F6]))|(?:[\u00F8-\u02FF]))|(?:[\u0370-\u037D]))|(?:[\u037F-\u1FFF]))|(?:[\u200C-\u200D]))|(?:[\u2070-\u218F]))|(?:[\u2C00-\u2FEF]))|(?:[\u3001-\uD7FF]))|(?:[\uF900-\uFFFE])))|(?:_))|(?:-))|(?:\\.))|(?:[0-9]))|(?:\u00B7))*)";
		cfg:canStartWith   "_" . 
QNAME	cfg:matches	"(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:[A-Z])|(?:[a-z]))|(?:[\u00C0-\u00D6]))|(?:[\u00D8-\u00F6]))|(?:[\u00F8-\u02FF]))|(?:[\u0370-\u037D]))|(?:[\u037F-\u1FFF]))|(?:[\u200C-\u200D]))|(?:[\u2070-\u218F]))|(?:[\u2C00-\u2FEF]))|(?:[\u3001-\uD7FF]))|(?:[\uF900-\uFFFE]))(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:[A-Z])|(?:[a-z]))|(?:[\u00C0-\u00D6]))|(?:[\u00D8-\u00F6]))|(?:[\u00F8-\u02FF]))|(?:[\u0370-\u037D]))|(?:[\u037F-\u1FFF]))|(?:[\u200C-\u200D]))|(?:[\u2070-\u218F]))|(?:[\u2C00-\u2FEF]))|(?:[\u3001-\uD7FF]))|(?:[\uF900-\uFFFE])))|(?:_))|(?:-))|(?:\\.))|(?:[0-9]))|(?:\u00B7))*)?:(?:(?:(?:_)|(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:[A-Z])|(?:[a-z]))|(?:[\u00C0-\u00D6]))|(?:[\u00D8-\u00F6]))|(?:[\u00F8-\u02FF]))|(?:[\u0370-\u037D]))|(?:[\u037F-\u1FFF]))|(?:[\u200C-\u200D]))|(?:[\u2070-\u218F]))|(?:[\u2C00-\u2FEF]))|(?:[\u3001-\uD7FF]))|(?:[\uF900-\uFFFE]))))(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:[A-Z])|(?:[a-z]))|(?:[\u00C0-\u00D6]))|(?:[\u00D8-\u00F6]))|(?:[\u00F8-\u02FF]))|(?:[\u0370-\u037D]))|(?:[\u037F-\u1FFF]))|(?:[\u200C-\u200D]))|(?:[\u2070-\u218F]))|(?:[\u2C00-\u2FEF]))|(?:[\u3001-\uD7FF]))|(?:[\uF900-\uFFFE])))|(?:_))|(?:-))|(?:\\.))|(?:[0-9]))|(?:\u00B7))*)?";
		cfg:canStartWith   "a" . 
#VARNAME	cfg:matches	"(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:[A-Z])|(?:[a-z]))|(?:[\u00C0-\u00D6]))|(?:[\u00D8-\u00F6]))|(?:[\u00F8-\u02FF]))|(?:[\u0370-\u037D]))|(?:[\u037F-\u1FFF]))|(?:[\u200C-\u200D]))|(?:[\u2070-\u218F]))|(?:[\u2C00-\u2FEF]))|(?:[\u3001-\uD7FF]))|(?:[\uF900-\uFFFE])))|(?:_))|(?:[0-9]))|(?:\u00B7))*";
#		cfg:canStartWith   "" . 
VAR2	cfg:matches	"\\$(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:[A-Z])|(?:[a-z]))|(?:[\u00C0-\u00D6]))|(?:[\u00D8-\u00F6]))|(?:[\u00F8-\u02FF]))|(?:[\u0370-\u037D]))|(?:[\u037F-\u1FFF]))|(?:[\u200C-\u200D]))|(?:[\u2070-\u218F]))|(?:[\u2C00-\u2FEF]))|(?:[\u3001-\uD7FF]))|(?:[\uF900-\uFFFE])))|(?:_))|(?:[0-9]))|(?:\u00B7))*)";
		cfg:canStartWith   "$" . 
VAR1	cfg:matches	"\\?(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:(?:[A-Z])|(?:[a-z]))|(?:[\u00C0-\u00D6]))|(?:[\u00D8-\u00F6]))|(?:[\u00F8-\u02FF]))|(?:[\u0370-\u037D]))|(?:[\u037F-\u1FFF]))|(?:[\u200C-\u200D]))|(?:[\u2070-\u218F]))|(?:[\u2C00-\u2FEF]))|(?:[\u3001-\uD7FF]))|(?:[\uF900-\uFFFE])))|(?:_))|(?:[0-9]))|(?:\u00B7))*)";
		cfg:canStartWith   "?" . 


#____________________________________________________

#  Axioms reducing the shortcut CFG terms to cfg:musBeOneSequence.

{ ?x cfg:zeroOrMore ?y } => {?x cfg:mustBeOneSequence ( () (?y ?x) ) }.

