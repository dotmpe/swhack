# Author: sbp
#  $Id$

@prefix : <#> .
@prefix log: <http://www.w3.org/2000/10/swap/log#> .
@prefix math: <http://www.w3.org/2000/10/swap/math#> .
@prefix string: <http://www.w3.org/2000/10/swap/string#> .

this log:forAll :x , :y , :z .

# Some simple rules

{ :x math:sumOf ("3" "5") } log:implies { :x :valueOf "3 + 5" } .
{ :x math:differenceOf ("8" "3") } log:implies { :x :valueOf "8 - 3" } .
{ :x math:differenceOf ("8") } log:implies { :x :valueOf "8 - (error?)" } .
{ :x math:factors ("5" "3" "2") } log:implies { :x :valueOf "5 * 3 * 2" } .
{ :x math:quotientOf ("7" "2") } log:implies { :x :valueOf "7 / 2" } .
{ :x math:remainderOf ("7" "2") } log:implies { :x :valueOf "7 % 2" } .
{ :x math:negation "3" } log:implies { :x :valueOf "3 negated" } .
{ "-3" math:negation :x } log:implies { :x :valueOf "what -3's the - of" } .
{ :x math:exponentiationOf ("2" "10") } log:implies { :x :valueOf "2^10" } .

{ ("3" "5") math:sum :x } log:implies { :x :valueOf "3 + 5" } .
{ ("8" "3") math:difference :x} log:implies { :x :valueOf "8 - 3" } .
{ ("8") math:difference :x } log:implies { :x :valueOf "8 - (error?)" } .
{ ("5" "3" "2") math:product :x} log:implies { :x :valueOf "5 * 3 * 2" } .
{ :x is math:quotient of ("7" "2") } log:implies { :x :valueOf "7 / 2" } .
{ :x is math:remainder of ("7" "2") } log:implies { :x :valueOf "7 % 2" } .
{ :x math:negation "3" } log:implies { :x :valueOf "3 negated" } .
{ "-3" math:negation :x } log:implies { :x :valueOf "what -3's the - of" } .
{ :x is math:exponentiation of ("2" "10") } log:implies { :x :valueOf "2^10" } .




# Check that comparison is really numeric and not string comparison
{ "008" math:greaterThan "70" } log:implies { :test10 a :FAILURE }.
{ "70" math:greaterThan "008" } log:implies { :test10 a :success }.

# A nested rule

{ :x math:sumOf ("3" [ math:differenceOf ("8" "3") ]) } 
   log:implies { :x :valueOf "3 + (8 - 3)" } .

# Getting the amount of members in a list

{ :x a :List; math:memberCount :y } log:implies { :x :memberCount :y } .
("x" "y" "z") a :List .

# An example implementation: error flagging a list with too many members

{ :x a :TwoItemedList; math:memberCount [ math:notEqualTo "2" ] } 
   log:implies { :x :hasAn :Error } .

("p" "q") a :TwoItemedList .
("p" "q" "r") a :TwoItemedList .

# Big test

{ :x math:sumOf ([ math:quotientOf ("7" "2") ] 
   [ math:exponentiationOf ([ math:remainderOf  ("7" "2")] "10000000") ]
   [ is math:memberCount of ("a" "b" "c" "d" "e") ]) } log:implies 
{ :x :valueOf "(7 / 2) + ((7 % 2)^10000000) + 5 [should be 9.5]" } .

# Combinatorial test

"3.1415926" a :testValue.
"1729" a :testValue.
"0" a :testValue.
"1e7" a :testValue.

{ :x a :testValue. :y a :testValue.
  (:x [ is math:difference of (:y :x)]) math:sum :y } log:implies {:x :worksWith :y}.
 
{ :x a :testValue. :y a :testValue.
  [ is math:sum of (:x [ is math:difference of (:y :x)])] math:notEqualTo :y } log:implies {:x :FAILS :y}.
 
# For purging

log:implies a log:Chaff .
log:forAll a log:Chaff .
