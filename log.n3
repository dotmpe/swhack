#   n3 definition of some logical terms
#
# These raise the level above RDF's pure relational data,
# and Web Ontology's ontological level, to allow rules to be expressed
# and inference done.
# 
# $Id$

@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix doc: <http://www.w3.org/2000/01/pim/doc#>.
@prefix log: <http://www.w3.org/2000/10/swap/log#>.
@prefix : <#>.

log:N3Document a rdfs:Class;
	rdfs:comment	"""A document which, which parsed as Notation3
as defined in general by http://www.w3.org/DesignIssues/Notation3.html
and this schema, conveys the intent of the author by the semantics defined
on those specifications, and the semantics defined by the specifications
of any identifiers used in the document.
""" .

################################################## Syntactic level
#
#  It isn't clear to me that these should be described as Properties
#  and Classes.  They operate at a level of symbol identity, not daml:Equivalence.
#

log:equalTo a rdf:Property;
    rdfs:comment
"""Equality in this sense is actually the same URI.
Do not confuse with daml:EquivalentTo.
A cwm built-in logical operator.
""".

log:notEqualTo a rdf:Property;
    rdfs:comment
"""Equality in this sense is actually the same URI.
Do not confuse with daml:EquivalentTo.
A cwm built-in logical operator.
""".

log:rawType a rdf:Property;
    rdfs:comment """
This is a low-level langauge type, one of log:Formula, log:Literal, 
log:List, log:Other.  I only use testing for log:Formula right now (tbl 2001/9/17).
List and Other are not stable and may change.
Example: semanticsOrError returns either a Formula or a String.
""".

log:Formula a rdfs:Class.
log:String  a rdfs:Class.
log:List    a rdfs:Class.     # Syntactic things
log:Other   a rdfs:Class.     # Not one of the above.

#   The following are inherent in the translation of N3 syntax to quad representation:

log:forSome a rdf:Property;  #@@@@@ buggy!
    rdfs:comment """A is true for some object for which here we use B. This
                is NOT a real rdf property in its behaviour - a pseudoproperty.""" ;
	   rdfs:domain log:Formula.


log:forAll a rdf:Property;
    rdfs:comment "A is true for any object in place of B" .


#########################################################
#
#  The following are used for inference
#

log:Truth a rdfs:Class;
    rdfs:comment """Something which is true: belive it as you would belive this.
	       Understood natively by cwm in that it will execute rules in a formula
         declared a Truth within a formula it is already taking rules from.""".

#log:Falsehood a rdf:Class;
#	rdfs:comment "Something which is not true. Not the complement of True!";
#	rdfs:domain log:context.
#

log:implies a rdf:Property;
    rdfs:comment "Logical implication. Understood natively by cwm.";
    rdfs:range log:Formula;
    rdfs:isDefinedBy <>;
    rdfs:range log:Formula.

log:includes a rdf:Property;
    rdfs:comment "One formula is subset of other. Understood natively by cwm.";
    rdfs:range log:Formula;
    rdfs:isDefinedBy <>;
    rdfs:range log:Formula.

log:notIncludes a rdf:Property;
    rdfs:comment "One formula is NOT a subset of other. Understood natively by cwm.";
    rdfs:range log:Formula;
    rdfs:isDefinedBy <>;
    rdfs:range log:Formula.


log:parsedAsN3 a rdf:Property;
    rdfs:comment "A string, parsed as N3, gives this formula.";
    rdfs:label "parses to";
    rdfs:domain log:String;
    rdfs:range log:Formula.
 
log:semantics a rdf:Property;   # (was resolvesTo but we use role nouns by preference)
    rdfs:domain doc:Work;
    rdfs:range  log:Formula;
    rdfs:label  "semantics";
    rdfs:comment """This connects a document and the formula it parses to.
        Cwm knows how to go get a document and parse it in order to evaluate this.""".

log:semanticsOrError a rdf:Property;   #
    rdfs:domain doc:Work;
    rdfs:label  "semantics or error message";
    rdfs:comment """This connects a document and either the formula it parses to,
        or an error message explaining what went wromg with trying. See semantics.
        Cwm knows how to go get a document and parse it in order to evaluate this.""".

log:racine a rdf:Property;
    rdfs:comment """For anything identified by a URI with a fragid, this is the
        thing identified by the same URI without a hash or fragid""".

log:content a rdf:Property;   # (was hasContent but we use role nouns by preference)
    rdfs:domain doc:Work;
    rdfs:range  log:String;
    rdfs:label  "content";
    rdfs:comment """This connects a document and a string that represents it.
        Cwm knows how to go get a document in order to evaluate this.""".

#  Merge two formulae

log:conjunction a rdf:Property;
    rdfs:label "conjunction";
    rdfs:domain log:List;
    rdfs:range  log:Formula;
    rdfs:comment """"A function to merge formulae: logical AND.

The subject is a list of formulae.
The object, which can be generated, is a formula containing a copy
of each of the formulae in the list on the left.
A cwm built-in function.
""".

#  Find the set of ALL statements entailed by a given formula.

log:conclusion a rdf:Property;
    rdfs:label "conclusion";
    rdfs:domain log:Formula;
    rdfs:range log:Formula;
    rdfs:comment """All possible conclusions which can be drawn from a formula.

The object of this function is the set of conclusions which can be
drawn from the subject formula, by successively applying any
rules it contains to the data it contains. This is equivalent to
cwm's "--think" command line function.  It does use built-ins, so
it may for example indirectly invoke other documents, validate
signatures, etc.
""".

################### Purge control

log:Chaff a rdfs:Class;
    rdfs:comment """Any statement mentioning anything in this class
is considered boring and purged by the cwm --purge option.""".

 

################# Simple Builtins:
#
#
log:uri a rdf:Property;
    rdfs:comment 
"""This allows one to look at the actual string of the URI
which identifies this.
Cwm can get the URI of a resource or get the resource from the URI.
This is a level breaker, breaking the rule of not looking inside a
URI.   Use to replace RDF's old "aboutEach" functionality.""";
    rdfs:range log:String.

############# Rules
# Rule names may change.
# Conversion between falsehood and implication:
#rule1 log:forAll :x, :y, :z; =
#{
#    { :x log:implies :y } log:means {  { :x a :Truth . :y a :Falsehood.} a:Falsehood}.
#} .
#
# etc etc

# ends

