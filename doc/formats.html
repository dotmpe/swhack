<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Comparing Formats</title>
  <meta name="generator" content="amaya 7.1, see http://www.w3.org/Amaya/" />
  <link href="main.css" rel="stylesheet" type="text/css" />
</head>

<body>
<p><a href="/">W3C</a> | <a href="/2001/sw/Overview.html">Semantic Web</a>
| <a href="/2000/01/sw/Overview.html">Advanced Development</a> | <a href="/2000/10/swap/">SWAP</a> | <a href="/2000/10/swap/doc/">Tutorial</a> | Comparing Formats</p>

<h1>Comparing Formats</h1>

<p>There are a many languages in use today for exchanging RDF-structured
information.   Here's a simple example rendered in many different
ways.   Converters to between some of these formats, but not others
(yet).
</p>

<p>@@@ TODO: Make give him another name, 'Patrick Smith' to show off
cardinality issues.</p>

<p>@@@ rename example.org to ...test/demo1 </p>

<h2>English (Very Informal)</h2>

<p class="example">
There is person, Pat, whose full name is "Pat Smith".  Pat has a
pet dog named "Rover".   
</p>

<h2>English Hypertext (Informal)</h2>

<p>Here the ambiguity of terms is addressed by making the words be
hypertext links.  The links may or may not work, depending on the
servers involved.  For this example, several of the terms are at
"example.org", so they do not actually function.  Other terms (like
"Pat") are linked relative to this document for brevity; clicking on
such terms fails as well.
</p>

<p class="example">
<a href="#pat">Pat</a> <a
href="http://www.w3.org/1999/02/22-rdf-syntax-ns#type">is a</a> <a
href="http://www.example.org/BiologicalOrganisms#Human">human</a> with
the <a href="http://www.example.org/PersonalNotes#name">name</a> "Pat
Smith".  <a href="#pat">Pat</a> has a <a
href="http://www.example.org/PersonalNotes#pet">pet</a>, <a
href="http://www.w3.org/1999/02/22-rdf-syntax-ns#type">a</a> <a
href="http://www.example.org/BiologicalOrganisms#Dog">dog</a>, with
the <a href="http://www.example.org/PersonalNotes#name">name</a>
"Rover".
</p>

<h2>N3</h2>

<pre>
@prefix : <#> .
@prefix bio: &lt;http://www.example.org/BiologicalOrganisms#&gt; .
@prefix per: &lt;http://www.example.org/PersonalNotes#&gt; .
    
:pat     a bio:Human;
     per:name "Pat Smith";
     per:pet  [
         a bio:Dog;
         per:name "Rover" ] .
</pre>

<h2>Directed Labeled Graph</h2>
<img class="example" src="formats-example1" />

<h2>RDF/XML</h2>

<pre>
&lt;rdf:RDF xmlns="file:/home/sandro/cvs/cvs.w3c.org/WWW/2000/10/swap/doc/formats/pat.n3#"
    xmlns:bio="http://www.example.org/BiologicalOrganisms#"
    xmlns:per="http://www.example.org/PersonalNotes#"
    xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;

    &lt;bio:Human rdf:about="#pat"&gt;
        &lt;per:name&gt;Pat Smith&lt;/per:name&gt;
        &lt;per:pet&gt;
            &lt;bio:Dog&gt;
                &lt;per:name&gt;Rover&lt;/per:name&gt;
            &lt;/bio:Dog&gt;
        &lt;/per:pet&gt;
    &lt;/bio:Human&gt;
&lt;/rdf:RDF&gt;
</pre>

<h2>N-Triples</h2>

<p>With @prefix:</p>
<pre>
@prefix : <#> .
@prefix bio: &lt;http://www.example.org/BiologicalOrganisms#&gt; .
@prefix per: &lt;http://www.example.org/PersonalNotes#&gt; .
@prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;.

:pat rdf:type bio:Human.
:pat per:name "Pat Smith".
:pat per:pat _:genid1.
_:genid1 rdf:type bio:Dog.
_:genid1 per:name "Rover".
</pre>

<p>In standard form:</p>
<pre>
&lt;file:/home/sandro/cvs/cvs.w3c.org/WWW/2000/10/swap/doc/formats/pat.rdf#pat&gt; &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; &lt;http://www.example.org/BiologicalOrganisms#Human&gt; .
&lt;file:/home/sandro/cvs/cvs.w3c.org/WWW/2000/10/swap/doc/formats/pat.rdf#pat&gt; &lt;http://www.example.org/PersonalNotes#name&gt; "Pat Smith" .
&lt;file:/home/sandro/cvs/cvs.w3c.org/WWW/2000/10/swap/doc/formats/pat.rdf#pat&gt; &lt;http://www.example.org/PersonalNotes#pet&gt; _:genid1 .
_:genid1 &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; &lt;http://www.example.org/BiologicalOrganisms#Dog&gt; .
_:genid1 &lt;http://www.example.org/PersonalNotes#name&gt; "Rover" .
</pre>

<h2>Prolog</h2>

<p>Without namespaces, this is very terse:</p>
<pre>
human(pat).
dog(rover).            % we have to assign a name
name(pat, "Pat Smith").
name(rover, "Rover").
pet(pat, rover).
</pre>

<p>One approach to namespaces:</p>
<pre>
ns(bio_, "http://www.example.org/BiologicalOrganisms#").
ns(per_, "http://www.example.org/PersonalNotes#").
bio_Human(pat).
bio_Dog(rover).      
per_name(pat, "Pat Smith").
per_name(rover, "Rover").
per_pet(pat, rover).
</pre>

<h2>SQL</h2>

<h3>Table Relating URIs to Internal IDs</h3>

<p>URIs are big, variable-length keys; it's much more efficient to
translate them into an internal id.  If the "uri" is NULL, this
resource is anonymous (a bNode, like a NodeID in RDF/XML).</p>

<pre>
CREATE TABLE uri (
  id INT AUTO_INCREMENT PRIMARY KEY,    # PRIMARY = UNIQUE and NOT NULL
  uri BLOB,   # BLOB is also called LONGVARBINARY 
  UNIQUE KEY uri (uri(64))  # length is just a tuning knob
);
INSERT INTO uri (uri) VALUES ('http://www.w3.org/1999/02/22-rdf-syntax-ns#type');
INSERT INTO uri (uri) VALUES ('http://www.example.org/BiologicalOrganisms#Human');
INSERT INTO uri (uri) VALUES ('http://www.example.org/BiologicalOrganisms#Dog');
INSERT INTO uri (uri) VALUES ('http://www.example.org/PersonalNotes#name');
INSERT INTO uri (uri) VALUES ('http://www.example.org/PersonalNotes#pet');
INSERT INTO uri (uri) VALUES ('#pat');
INSERT INTO uri (uri) VALUES (NULL);   # this is rover, who has no URI

mysql> select * from uri;
+----+--------------------------------------------------+
| id | uri                                              |
+----+--------------------------------------------------+
|  1 | http://www.w3.org/1999/02/22-rdf-syntax-ns#type  |
|  2 | http://www.example.org/BiologicalOrganisms#Human |
|  3 | http://www.example.org/BiologicalOrganisms#Dog   |
|  4 | http://www.example.org/PersonalNotes#name        |
|  5 | http://www.example.org/PersonalNotes#pet         |
|  6 | #pat                                             |
|  7 | NULL                                             |
+----+--------------------------------------------------+
</pre>

<h3>Option 1: One Table, One Column Per Predicate</h3>

<p>This is a simple, intuitive approach, but...</p>
<ul>
<li>You need to add a new column with each new predicate you use</li>
<li>Predicates must be known to be individual-valued or data-valued;
and if data-valued, then what type?</li>
<li>You cannot have multivalued (cardinality > 1) properties</li>
</p>

<pre>
CREATE TABLE resource ( 
  id INT PRIMARY KEY,
  type INT,           # http://www.w3.org/1999/02/22-rdf-syntax-ns#type
  name varchar(255),  # http://www.example.org/PersonalNotes#name
  pet INT             # http://www.example.org/PersonalNotes#pet
);
INSERT INTO resource (id, type, name, pet) VALUES (6, 2, 'Pat Smith', 7);
INSERT INTO resource (id, type, name) VALUES (7, 3, 'Rover');

mysql> select * from resource;
+----+------+-----------+------+
| id | type | name      | pet  |
+----+------+-----------+------+
|  6 |    2 | Pat Smith |    7 |
|  7 |    3 | Rover     | NULL |
+----+------+-----------+------+
</pre>

<h3>Option 2: One Table Per Class, One Column Per Predicate</h3>

<p>Here we avoid having such wide tables, and our modeling better
matches the normal database modeling.  On the other hand, we have 
some conceptual redundancy between human.name and dog.name, because
there is no support for inheritance.
</p>

<pre>
CREATE TABLE human (  # http://www.example.org/BiologicalOrganisms#Human
  id INT PRIMARY KEY,
  name varchar(255),  # http://www.example.org/PersonalNotes#name
  pet INT             # http://www.example.org/PersonalNotes#pet
);
CREATE TABLE dog (  # http://www.example.org/BiologicalOrganisms#Dog
  id INT PRIMARY KEY,
  name varchar(255)   # http://www.example.org/PersonalNotes#name
);
INSERT INTO human VALUES (6, 'Pat Smith', 7);
INSERT INTO dog   VALUES (7, 'Rover');

mysql> select * from human, dog where human.pet=dog.id;
+----+-----------+------+----+-------+
| id | name      | pet  | id | name  |
+----+-----------+------+----+-------+
|  6 | Pat Smith |    7 |  7 | Rover |
+----+-----------+------+----+-------+
</pre>


<h3>Option 3: One Table Per Predicate</h3>

<p>Here we can support duplicate values.</p>

<pre>
CREATE TABLE name (  # http://www.example.org/PersonalNotes#name
  subject INT NOT NULL,
  object varchar(255),
  INDEX(subject),
  UNIQUE INDEX(subject, object)
);
CREATE TABLE pet (   # http://www.example.org/PersonalNotes#pet
  subject INT NOT NULL,
  object INT,
  INDEX(subject),
  UNIQUE INDEX(subject, object)
);
CREATE TABLE type (   # http://www.w3.org/1999/02/22-rdf-syntax-ns#type
  subject INT NOT NULL,
  object INT,
  INDEX(subject),
  UNIQUE INDEX(subject, object)
);
INSERT INTO name VALUES (6, 'Pat Smith');
INSERT INTO name VALUES (6, 'Patrick Smith');
INSERT INTO name VALUES (7, 'Rover');
INSERT INTO pet VALUES (6, 7);
INSERT INTO type VALUES (6, 2);
INSERT INTO type VALUES (7, 3);

mysql> select * from name;                   
+---------+---------------+
| subject | object        |
+---------+---------------+
|       6 | Pat Smith     |
|       6 | Patrick Smith |
|       7 | Rover         |
+---------+---------------+

mysql> select * from pet;
+---------+--------+
| subject | object |
+---------+--------+
|       6 |      7 |
+---------+--------+

mysql> select * from type;
+---------+--------+
| subject | object |
+---------+--------+
|       6 |      2 |
|       7 |      3 |
+---------+--------+

<h3>Option 4: One Table of Triples, One Table Of Resources</h3>

<p>If we redo our URIs table as a "resources" table, with literals as
well as URIs, we have some more options.</p>
<pre>
CREATE TABLE resources (
  id INT AUTO_INCREMENT PRIMARY KEY,    # PRIMARY = UNIQUE and NOT NULL
  # either provide a uri
  uri BLOB, 
  # or a literal_value, which might have a datatype and language
  literal_value BLOB,
  datatype INT,
  language VARCHAR(5),
  UNIQUE KEY (uri(64))  # length is just a tuning knob
);
INSERT INTO resources (uri) VALUES ('http://www.w3.org/1999/02/22-rdf-syntax-ns#type');
INSERT INTO resources (uri) VALUES ('http://www.example.org/BiologicalOrganisms#Human');
INSERT INTO resources (uri) VALUES ('http://www.example.org/BiologicalOrganisms#Dog');
INSERT INTO resources (uri) VALUES ('http://www.example.org/PersonalNotes#name');
INSERT INTO resources (uri) VALUES ('http://www.example.org/PersonalNotes#pet');
INSERT INTO resources (uri) VALUES ('#pat');
INSERT INTO resources (uri) VALUES (NULL);   # this is rover, who has no URI
INSERT INTO resources (literal_value) VALUES ('Pat Smith');
INSERT INTO resources (literal_value) VALUES ('Patrick Smith');
INSERT INTO resources (literal_value) VALUES ('Rover');

mysql> select * from resources;
+----+--------------------------------------------------+---------------+----------+----------+
| id | uri                                              | literal_value | datatype | language |
+----+--------------------------------------------------+---------------+----------+----------+
|  1 | http://www.w3.org/1999/02/22-rdf-syntax-ns#type  | NULL          |     NULL | NULL     |
|  2 | http://www.example.org/BiologicalOrganisms#Human | NULL          |     NULL | NULL     |
|  3 | http://www.example.org/BiologicalOrganisms#Dog   | NULL          |     NULL | NULL     |
|  4 | http://www.example.org/PersonalNotes#name        | NULL          |     NULL | NULL     |
|  5 | http://www.example.org/PersonalNotes#pet         | NULL          |     NULL | NULL     |
|  6 | #pat                                             | NULL          |     NULL | NULL     |
|  7 | NULL                                             | NULL          |     NULL | NULL     |
|  8 | NULL                                             | Pat Smith     |     NULL | NULL     |
|  9 | NULL                                             | Patrick Smith |     NULL | NULL     |
| 10 | NULL                                             | Rover         |     NULL | NULL     |
+----+--------------------------------------------------+---------------+----------+----------+
</pre>

<p>Then we can have a simple table of triples:</p>

<pre>
CREATE TABLE triples (
  subject INT NOT NULL,
  predicate INT NOT NULL,
  object INT NOT NULL,
  UNIQUE INDEX(subject, predicate, object),
  INDEX(predicate, object),
  INDEX(object, predicate)
);
INSERT INTO triples VALUES (6, 4, 8);
INSERT INTO triples VALUES (6, 4, 9);
INSERT INTO triples VALUES (7, 4, 10);
INSERT INTO triples VALUES (6, 1, 2);
INSERT INTO triples VALUES (7, 1, 3);
INSERT INTO triples VALUES (6, 5, 7);

mysql> select * from triples; 
+---------+-----------+--------+
| subject | predicate | object |
+---------+-----------+--------+
|       6 |         1 |      2 |
|       6 |         4 |      8 |
|       6 |         4 |      9 |
|       6 |         5 |      7 |
|       7 |         1 |      3 |
|       7 |         4 |     10 |
+---------+-----------+--------+

mysql> select s.id, s.uri, p.uri as "predicate", 
       o.id, o.uri, o.literal_value as "lit"
       from triples, resources as s, resources as p, resources as o
       where s.id=triples.subject AND
             p.id=triples.predicate AND
             o.id=triples.object;
+----+------+-------------------------------------------------+----+--------------------------------------------------+---------------+
| id | uri  | predicate                                       | id | uri                                              | lit           |
+----+------+-------------------------------------------------+----+--------------------------------------------------+---------------+
|  6 | #pat | http://www.w3.org/1999/02/22-rdf-syntax-ns#type |  2 | http://www.example.org/BiologicalOrganisms#Human | NULL          |
|  6 | #pat | http://www.example.org/PersonalNotes#name       |  8 | NULL                                             | Pat Smith     |
|  6 | #pat | http://www.example.org/PersonalNotes#name       |  9 | NULL                                             | Patrick Smith |
|  6 | #pat | http://www.example.org/PersonalNotes#pet        |  7 | NULL                                             | NULL          |
|  7 | NULL | http://www.w3.org/1999/02/22-rdf-syntax-ns#type |  3 | http://www.example.org/BiologicalOrganisms#Dog   | NULL          |
|  7 | NULL | http://www.example.org/PersonalNotes#name       | 10 | NULL                                             | Rover         |
+----+------+-------------------------------------------------+----+--------------------------------------------------+---------------+
</pre>



<h2>XML (but not RDF/XML)</h2>

<p>The <strong>striped</strong> or <strong>alternating-normal
form</strong> approach uses a markup language designed for the
application domain.  Conversion to and from triples requires
specialized software</p>

<pre>
&lt;Human&gt;
  &lt;uri&gt;#pat&lt;/uri&gt;
  &lt;name&gt;Pat Smith&lt;/name&gt;
  &lt;pet&gt;
    &lt;Dog&gt;
     &lt;name&gt;Rover&lt;/name&gt;
    &lt;/Dog&gt;
  &lt;/pet&gt;
&lt;/Human&gt;
</pre>

<p>An alternative is to use <strong>XML Triples</strong>.  This does
not involve domain-specific markup.   Several candidate DTDs/Schemes
have been proposed; this is just one strawman.  For some applications,
this kind of syntax may be easier than RDF/XML or a striped syntax.</p>

<pre>
&lt;!DOCTYPE Graph [
 &lt;!ENTITY rdf    "http://www.w3.org/1999/02/22-rdf-syntax-ns#"&gt;
 &lt;!ENTITY bio    "http://www.example.org/BiologicalOrganisms#"&gt;
 &lt;!ENTITY per    "http://www.example.org/PersonalNotes#"&gt;
]&gt;
&lt;Graph&gt;
  &lt;Triple&gt;
    &lt;subject&gt;&lt;uri&gt;#pat&lt;/uri&gt;&lt;/subject&gt;
    &lt;predicate&gt;&lt;uri&gt;&amp;rdf;type&lt;/uri&gt;&lt;/predicate&gt;
    &lt;object&gt;&lt;uri&gt;&amp;bio;Human&lt;/uri&gt;&lt;/object&gt;
  &lt;/Triple&gt;
  &lt;Triple&gt;
    &lt;subject&gt;&lt;uri&gt;#pat&lt;/uri&gt;&lt;/subject&gt;
    &lt;predicate&gt;&lt;uri&gt;&amp;per;name&lt;/uri&gt;&lt;/predicate&gt;
    &lt;object&gt;&lt;literal&gt;Pat Smith&lt;/literal&gt;&lt;/object&gt;
  &lt;/Triple&gt;
  &lt;Triple&gt;
    &lt;subject&gt;&lt;uri&gt;#pat&lt;/uri&gt;&lt;/subject&gt;
    &lt;predicate&gt;&lt;uri&gt;&amp;per;pet&lt;/uri&gt;&lt;/predicate&gt;
    &lt;object&gt;&lt;nodeID&gt;genid1&lt;/nodeID&gt;&lt;/object&gt;
  &lt;/Triple&gt;
  &lt;Triple&gt;
    &lt;subject&gt;&lt;nodeID&gt;genid1&lt;/nodeID&gt;&lt;/subject&gt;
    &lt;predicate&gt;&lt;uri&gt;&amp;rdf;type&lt;/uri&gt;&lt;/predicate&gt;
    &lt;object&gt;&lt;uri&gt;&amp;bio;Dog&lt;/uri&gt;&lt;/object&gt;
  &lt;/Triple&gt;
  &lt;Triple&gt;
    &lt;subject&gt;&lt;nodeID&gt;genid1&lt;/nodeID&gt;&lt;/subject&gt;
    &lt;predicate&gt;&lt;uri&gt;&amp;per;name&lt;/uri&gt;&lt;/predicate&gt;
    &lt;object&gt;&lt;literal&gt;Rover&lt;/literal&gt;&lt;/object&gt;
  &lt;/Triple&gt;
&lt;/Graph&gt;
</pre>

<h2>Javascript and Python</h2>

<p>The RDF model maps fairly well to several
common programming constructs, especially those found in interpreted
object-oriented languages, like Javascript and Python.   Still, this
mapping is not perfect.</p>

<p>This simple approach ignores URI and cardinality issues; it only
allows pat to have one name and one pet:</p>

<pre>
pat = Human()
rover = Dog()
pat.name = "Pat Smith"
rover.name = "Rover"
pat.pet = rover
</pre>

<p>We can begin to consider cardinality:</p>

<pre>
pat = Human()
rover = Dog()
pat.name.append("Pat Smith")
rover.name.append("Rover")
pat.pet.append(rover)
</pre>

<p>But to be more complete, we need something like this which loses
the simplicity of the built-in model:</p>

<pre>
pat = Resource()
rover = Resource()
pat.addProperty(  ns.rdf.type, ns.bio.Human)
rover.addProperty(ns.rdf.type, ns.bio.Dog)
pat.addProperty(  ns.per.name, "Pat Smith")
rover.addProperty(ns.per.name, "Rover")
pat.addProperty(  ns.perpet, rover)
</pre>




<p></p>
<hr />

<p>$Id$</p>
</body>
</html>
