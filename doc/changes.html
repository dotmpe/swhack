<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Cwm features wished for and done</title>
  <meta name="generator" content="amaya 7.1, see http://www.w3.org/Amaya/" />
  <link href="style.css" rel="stylesheet" type="text/css" />
</head>

<body>

<div class="noprint">
<p><a href="/">W3C</a> | <a href="/2001/sw/Overview.html">Semantic Web</a> |
<a href="/2000/01/sw/Overview.html">Advanced Development</a> | <a
href="/2000/10/swap/">SWAP</a> | <a href="/2000/10/swap/doc/">Tutorial</a> |
Comparing Formats</p>
</div>

<h1>Cwm Changes 2003/08</h1>

<p>At this point cwm made a number of changes at once, so we document them
here.</p>

<p><small><code>@prefix test:
&lt;http://www.w3.org/2000/10/swap/test/regression#&gt;.</code></small></p>
<ol>
  <li><p>The <strong>namespaces</strong> used for lists changed from DAML to
    RDF. The namespace used for "=" switched to OWL. DAML and DAML+OIL are
    used no more, though we remember them fondly. This change actually
    shouldn't change much in many applications, where files use the
    collection syntax in RDF or the () and = syntaxes in N3. It does affect
    the order of statements cwm uses to pretty-print files.</p>
  </li>
  <li><strong>Lists</strong> are handled differently internally. This is a
    bit of a an experiment. Instead of being stored in their first/rest forms
    in the graph, complete lists are stored as List objects. Thse are first
    class objects. . 
    <ul>
      <li>You can match against lists. Unification of formlae will catch
        identical lists such as ( &lt;a&gt; &lt;b&gt; ) matching against (
        &lt;a&gt; &lt;b&gt; ) because Lists are interned, and also unify ( ?x
        ?y ) with ( &lt;a&gt; &lt;b&gt; ). This still does not work , however
        with formulae. Watch this space, though,as this may change.</li>
      <li>The list-handling is not complete when constructing lists. (test
        that fail: test/list/gk*.n3 -- sorry Graham!). Lists generated are
        currently not available to be queried. rdf:first and rdf:rest are
        built-in functions which work to dismantle lists, but currently
        <strong>not to build them</strong>. or, that is, you can build them
        but you can't directly query them... watch this space. Hopefully this
        will be fixed, and the lists will behave just as thoug the actual
        graph contained rdf:first and rdf:rest triples (but be more
        efficient).</li>
      <li>You should be able to generate lists from built-ins if you are
        making new built-in functions. Just return a python sequence from
        evaluateObject().</li>
      <li>The unification (query) engine was complicated by the fact that
        lists in the antecedent can be assumed as all lists exist by axiom.
        The last release of llyn had a bug (<code>test:t1018b2</code>) with
        that - and wrapping my head round that caused me to decide it was
        time for the change. It is nowsimpler in that regard.</li>
      <li>In canonical comparisons, Lists are greater than literals and
        smaller than formulae. This may affect the ordering of cwm-generated
        files. Lists currently compare element by element, or if elements
        match, shortest is smallest.</li>
    </ul>
  </li>
  <li><strong>New option --data</strong> strips the store down to an RDF
    graph, losing universal variables (forAll's) and any statements which
    mentoin nested formulae. --purge-rules is now deprocated and does the
    same thing. (--purge-rules sed to be a just remove things menioning
    forAll or implies.)</li>
  <li><strong>Generated Ids</strong> have in the past been generated relative
    to the current input file (or base) like &lt;#_g0&gt;. This had two
    problems. The first is that purists point outthat cwm is assertingthings
    about the user's namespace which aren't necessarily true - why does cwm
    have the right to do this? The second is pragmatic: when two files
    already with cwm-generated genids were re-processed using cwm, it could
    under some cases end up reusing the same id. Now, cwm makes up, by
    default, much more resilient ones. It imagines a file called something
    like .run-19435661734.7651234 in the local directory, and uses that
    file's local space for its names. If you don't like this (eg for
    repeatable testing) you can set an environment variable
    <code><strong>CWM_RUN_NS</strong></code> to something like "#", which
    will create the original behaviour, or a specific namespace you know you
    won't reuse in related work.</li>
</ol>

<p></p>

<p>More changes 2003-08-25</p>
<ol>
  <li>2003-08  Pretty printing split from llyn.py to pretty.py. Interface may
    change.  Pretty printing should be faster now - for some runs it was
    taking a lot longer than the parsing and inference steps. It had never
    been designed for speed, but it was getting ridiculous.</li>
</ol>

<h3>For python cwm developers</h3>

<p></p>
<ol>
  <li>The store is being separated into components. llyn.py was too big. The
    idea is to be able to support a redland underlying store in the future.
    The unification engine which includes the built-in function operation now
    uses the store's api to access the store without peeking into
  internals.</li>
  <li>thing.py split into myStore.py and term.py </li>
  <li>It used to be that the universal and existential variables in a formula
    were stored in forAll and forSome psudo-property triples. This was
    basically a kludge. One had to be always aware that the pseudoproperties
    didn't act like real ones (no substitution for = etc). So now the lists
    of variables have goene into the formula objects. This should make it
    much easir for people tofollow whatis happeningin the code, and removes
    all kinds of special case code.</li>
  <li></li>
</ol>

<h2>Getting an old version</h2>

<p></p>

<p>You can get the old version before these 2.0 changes using CVS, by
checking out with the tag oldLists .</p>

<p><code>cvs update -r oldLists</code></p>

<p></p>

<h2>To Do:</h2>

<p></p>

<p>Performance:  Make test/perform test suite with standard tests for  </p>

<h3>Syntax</h3>

<p>RDF Output - bnodes</p>

<p>RDF Output - Collections</p>

<p>RDF Output: On lists, use exietnstials or bnodes not symbols</p>

<p>N3 syntax - transision from <code>this log:forAll</code> to
<code>@forAll</code>. Same for <code>forSome.</code></p>

<p>N3 syntax - test set syntax (,) (&lt;a&gt;,) (&lt;a&gt;, &lt;b&gt;)</p>

<p>Extended RDF output syntax for formulae (how? have RDF Core locked
<em>all</em> the exits? Prevents RDF2 not superset of RDF/XML1)</p>

<h3>Query/Inference</h3>

<p>Unify nested formulae</p>

<p>Built-ins for lists. in (needs muli value function, below); append,
prepend, second..seventh, last, concat.</p>

<p>Sets, plus builtins, plus syntax??</p>

<p>Builtin-s extracting closed world data: s=Q(F, y, G) is set of x such that
formula F.substite((y, x)) log:includes G.</p>

<p>Symbols used as variables as separate python class - save some time
checking occurrences</p>

<p>Paramodulation - smushing built into store. reuse redirection used for
lists?</p>

<p>Builtin operations:</p>
<ul>
  <li>Return many bindings from builtin eg list:in, os:argv</li>
  <li>Fairly complete XQ functions and operators implementations (use same
    URIs?)</li>
  <li>Extract datatype, language and string from a literal.</li>
</ul>

<p>Remove all vestiges of the old pair represetation of symbols.</p>

<p>Implement backward chainer (like Euler) on the same store. Allow forward
and backward chainers to interact, share built-ins.</p>

<h3>Store</h3>

<p>Implement versions of the store based on Redland, Jena, etc.</p>

<p>Implement rete method. Rules with state as objects. <em>&lt;= student
project?</em></p>

<p></p>

<h3>Net</h3>

<p>Implement <strong>persistent cache</strong> - make an ontology (based very
stongly on HTTP headers) for recording the results of an HTTP (etc) get. 
Store metadata about fetched ontologies. Build an index into the persistent
cache for offline working.  Functions: find the closure of these documents
under eg --closure=ptr and make sure than they are all in my persistent
cache.  Allow environment variable to specify persistent cache mode (default:
ontologies only, write to cache when online and expiry check fails, read from
cache when offline). Provide pcache.urlopen() as a transparent extension of
urlopen()</p>

<p></p>

<h3>Features done</h3>

<p>Done ==== - sucking in the schema (http library?)</p>

<p>--schemas ; - to know about r1 see r2;</p>

<p>- split Query engine out as subclass of RDFStore? (DWC) SQL-equivalent
client</p>

<p>- split out separate modules: CGI interface, command-line stuff, built-ins
(DWC 30Aug2001)</p>

<p>- (test/retest.sh is another/better list of completed functionality
--DWC)</p>

<p>- BUG: a [ b c ] d. gets improperly output. See anon-pred</p>

<p>- Separate the store hash table from the parser.</p>

<p>- DONE - regeneration of genids on output.</p>

<p>- DONE - repreentation of genids and foralls in model - regression test</p>

<p>- DONE (once!) Manipulation: { } as notation for bag of statements - DONE
- filter -DONE - graph match</p>

<p>-DONE - recursive dump of nested bags</p>

<p>- DONE - semi-reification - reifying only subexpressions</p>

<p>- DONE - Bug :x :y :z as data should match [ :y :z ] as query. Fixed by
stripping forSomes from top of query.</p>

<p>- BUG: {} is a context but that is lost on output!!! statements not
enough. See foo2.n3 - change existential representation :-( to make context a
real conjunction again? (the forSome triple is special in that you can't
remove it and reduce info) - filter out duplicate conclusions</p>

<p>- BUG! - DONE - Validation: validate domain and range constraints against
closuer of classes and mutually disjoint classes.</p>

<p>- Use unambiguous property to infer synomnyms (see sameDan.n3 test case in
test/retest.sh)</p>

<p>- schema validation - done partly but no "no schema for xx predicate".
ULTINS WE HAVE DONE</p>

<p>- includes(expr1, expr2) (cf &gt;= , dixitInterAlia )</p>

<p>- indirectlyImplies(expr1, expr2)</p>

<p>- startsWith(x,y)</p>

<p>- uri(x, str)</p>

<p>- usesNamespace(x,y) # find transitive closure for validation - awful
function in reality</p>

<p></p>

<p></p>

<p></p>

<p></p>

<p></p>

<p></p>

<div class="noprint">
<hr />

<p>$Id$</p>
</div>
</body>
</html>
