<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta name="generator"
    content="HTML Tidy for Linux/x86 (vers 1st February 2002), see www.w3.org" />

    <title>cwm - a general purpose data processor for the semantic
    web</title>
    <meta http-equiv="Content-Type"
    content="text/html; charset=iso-8859-1" />
    <link href="/StyleSheets/base.css" rel="stylesheet"
    type="text/css" />
  </head>

  <body lang="en">
    <p><a href="/">W3C</a> | <a
    href="/2000/01/sw/Overview.html">Semantic Web</a></p>

    <h1>Cwm</h1>

    <p>Cwm is a general-purpose data processor for the semantic
    web. It is a forward chaining reasoner which can be used for
    querying, checking, transforming and filtering information. Its
    core language is RDF, extended to include rules, and it uses
    RDF/XML or N3 serializations as required.</p>

    <p>Originally, from "Closed world machine" because it processed
    information in a limited space, cwm does not make any
    assumptions about a closed world. Think of it as defined area
    but with openings - like a valley. Cwm is written in
    python.</p>

    <ul>
      <li><a href="/2001/sw">The Semantic Web</a> at W3C</li>

      <li><a href="../Overview.html">Semantic Web Application
      Platform</a></li>

      <li><a href="http://infomesh.net/2001/cwm/">Sean Palmer's
      guide to cwm -- Sean keeps it more up to date than
      this!</a></li>

      <li><a href="../Primer.html">Notation3 Primer</a> - a quick
      introduction to semantic web using cwm and n3</li>
    </ul>

    <p><a id="Check" name="Check">Check out other programs which
    use the same formats</a>:</p>

    <ul>
      <li><a href="http://www.agfa.com/w3c/euler/">Euler</a> - a
      backward-chaining reasoner by Jos de Roo</li>

      <li><a
      href="http://www.unc.edu/~bparsia/sw/cwmclone/cwmclone.html">cwmclone</a>
      - a [partial?] clone of cwm by Bijan Parsia</li>

      <li>RDF::Notation3 perl module (<a
      href="http://archive.develooper.com/modules@perl.org/msg08120.html">
      submission</a> 10 Oct 2001 by Petr Cimprich )</li>
    </ul>

    <h2>Source</h2>

    <p>This <a href="http://dev.w3.org/cvsweb/2000/10/swap/">swap
    code</a> is not guaranteed but is open source and
    available:</p>

    <dl>
      <dt>Using CVS</dt>

      <dd>from the <a href="http://dev.w3.org/cvsweb/">public w3c
      CVS repository</a>.Check out *.py from the top level of the
      swap hierarchy to use it, check out the whole tree to
      develop</dd>

      <dt>From the web</dt>

      <dd>Get the files one by one. <a
      href="/2000/10/swap/cwm.py">cwm.py</a> is the main one. Save
      them into the same directory.</dd>
    </dl>

    <p>However you got the files,, set up an alias (.bat file, etc)
    to make the cwm command cwm="python
    /whereverYouPutThem/cwm.py"</p>

    <p>Have fun.</p>

    <h3>Prerequisites</h3>

    <ul>
      <li><strong><a
      href="http://www.python.org/">Python</a></strong>. That you
      need. It comes with many systems. If you don't have it, on
      debian type apt-get install python. On OSX, type <a
      href="http://fink.sourceforge.net/"><code>fink</code></a>
      <code>install python</code>. On cygwin, select python in the
      setup.exe installer..</li>

      <li>If you are reading things in RDF/XML format, you will
      need the <strong>pyxml</strong> python extension. Under
      debian, type <code>apt-get install pyxml.</code> Otherwise,
      untar it and in the right directory type python setup.py
      install. Under cygwin, select it in the the cygwin
      setup.exe.</li>

      <li>If you are using the public key cryptography builtins,
      you will need the <strong>amkCrypto</strong> python
      extension. Hopefully the necessary functionality will be in
      pycrypto soon (next release later than 2002/05). One version
      had a print statement in number.py#inverse --the print
      statement needs to be removed. Edit directory names
      appropriately in setup.py then run <code>python setup.py
      install</code>. Necessary changes for OSX: @@</li>
    </ul>

    <p>You can do all this under MSWindows but the easiest thing is
    to install cygwin (a unix-like environment for Windows) and run
    everything in there.</p>

    <h3 id="Closed">Features</h3>

    <p>This is a general purpose command-line application, in which
    triples are stored in/against the particular context in which
    they were read, eg RDF file or N3 { expression }. The features
    at the moment include</p>

    <ul>
      <li>Loading files in RDF and/or N3</li>

      <li>Applying rules written in N3 to the data.</li>

      <li>Filtering the data to the result of a particular
      query</li>

      <li>Generating RDF or N3 files from the result.</li>

      <li>Pretty printing data so that anonymous nodes are used
      creatively to minimize the number of explicit existentials
      (generated Ids).</li>

      <li>Generating arbitrary formats (using --strings)</li>

      <li>
        Using an internal knowledge of functions to resolve them
        within a query, including: 

        <ul>
          <li>Simple math and string operations</li>

          <li>Getting and parsing documents from the web</li>

          <li>Accessing command line arguments and environment
          variables</li>

          <li>Cryptography: hashing, generating keys, signing
          things and checking signatures.</li>
        </ul>
      </li>
    </ul>

    <p>Cwm will run as a command, and is designed to be usable as a
    simple data manipulator for RDF on the lines of sed, awk, etc
    or xsl.</p>

    <p>In progress.</p>

    <h4 id="Command">Command line parameters</h4>

    <p>Some, marked (flag), can occur anywhere on the command line.
    The others are processed in order from left to right.</p>

    <dl>
      <dt>--help</dt>

      <dd>generate a <strong>more up to date</strong> list of
      parameters</dd>

      <dt>--pipe</dt>

      <dd>don't store, just process serially. (doesn't lose comment
      lines!) (flag)</dd>

      <dt>--rdf</dt>

      <dd>input/output format XML/RDF format from now on</dd>

      <dt>--rdf=flags</dt>

      <dd>as above but sets flags as to how RDF is written</dd>

      <dt>--n3</dt>

      <dd>input/output is Notation3 from now on.</dd>

      <dt>--n3=flags</dt>

      <dd>as above, but also customizes N3 output. cwm --help for
      list of flags</dd>

      <dt>--ntriples</dt>

      <dd>As for n3, but customized to produce the "ntriples" N3
      subset.</dd>

      <dt>--rdf1out</dt>

      <dd>output format is RDF. (flag)</dd>

      <dt><em>uri</em></dt>

      <dd>load the resource. Parsed relative to the local
      directory, so a filename will work.</dd>

      <dt>--size</dt>

      <dd>Output the current size of the store.</dd>

      <dt>--apply=<em>uri</em></dt>

      <dd>Apply the rules in a given resource, once each, to the
      store, the conclusions being added to the store.</dd>

      <dt>--filter=<em>uri</em></dt>

      <dd>Apply the rules in a given resource, once each, to the
      store, replacing the original contents of the store with
      those things concluded from the rules.</dd>

      <dt>--rules</dt>

      <dd>Apply any rules in the store to the store itself,
      conclusions being added to the store.</dd>

      <dt>--think</dt>

      <dd>Do --rules and go on doing it until no more is
      generated.</dd>

      <dt>--purge</dt>

      <dd>Removes any triple containing a term that is declared to
      be of rdf:type log:Chaff</dd>

      <dt>--ugly</dt>

      <dd>Dump the store in a more or less random order. This tends
      to be messy, as related information is not grouped.</dd>

      <dt>--bySubject</dt>

      <dd>Dump the store grouping statements by subject. This tends
      to be better than -ugly, but the default is to make the
      output as readable as possible using anonymous nodes wherever
      possible, and is therefore recommended. (flag)</dd>

      <dt>--strings</dt>

      <dd>Output the objects of log:outputString statements,
      ordered by the subject</dd>
    </dl>

    <p>Note that where a <em>uri</em> is given, this can be a
    filename of course. The default base URI of the process is the
    file URI of a file in the current working directory, so a local
    filename will be a valid relative URI. This is how URIs were
    supposed to work.</p>

    <h4 id="Rule">Rule file format</h4>

    <p>A rule file is simply a notation3 file. A rule is a
    statement which asserts an implication using log:implies (where
    the namespace must be http://www.w3.org/2000/10/swap/log#)
    between premise and a conclusion. The premise is simply a
    template: cwm will search for all combinations of statements in
    the store which match the template. Variables must be
    explicitly connected to the enclosing context (often, the
    document) by a "log:forAll" statement. For each match, a
    conclusion is formed by taking the conclusion and in it
    replacing any variables which have been matched with the values
    found. The following is an example:</p>
<pre>
@prefix log: &lt;http://www.w3.org/2000/10/swap/log#&gt; .
@prefix mech: &lt;s1.n3#&gt; .

this log:forAll &lt;#x&gt; , &lt;#y&gt; .
{ &lt;#x&gt; mech:includes &lt;#y&gt; } log:implies { &lt;#y&gt; mech:partOf &lt;#x&gt; } .
</pre>

    <p>The @prefix directives define the prefixes log: and mech: as
    representing namespaces. The this log:forAll line declares #x
    and #y, two local identifiers, as being universally quantified
    variables in the context of this formula (this).</p>

    <h2>Built-in functions</h2>

    <p>Sean Palmer's guide is more up to date.</p>

    <h3>Logic</h3>

    <p>See the <a href="../log.n3">schema</a></p>

    <p><code>@prefix math: &lt;</code><a
    href="http://www.w3.org/2000/10/swap/log.n3"><code>http://www.w3.org/2000/10/swap/log</code></a>#<code>
    &gt;</code> .</p>

    <dl>
      <dt>log:implies</dt>

      <dd>One formula implies another, using log:forAll and
      log:forSome to indicate variables. This is the basic
      rule-building property. cwm looks for log:implies rules when
      --rules or --think options are used. The left hand side, the
      antecedent, can have built-in functions which are evaluated,
      as follows.</dd>

      <dt>log:includes</dt>

      <dd>Within a query, F includes G is true if statements in F
      allow G to be deduced. Variable substitution works across
      includes.</dd>

      <dt>log:notIncludes</dt>

      <dd>Opposite of includes. When no outstanding variables need
      to be resolved, cwm can check to see whether F has statements
      to justify G, and if not this binary operator succeeds. This
      is how you can make defaults. Use this as a form of "not"
      which makes sense in on the web.</dd>

      <dt>etc</dt>

      <dd>...</dd>
    </dl>

    <h3>Math</h3>

    <p>Simple math functions, where numbers are represented as RDF
    literal strings</p>

    <p><code>@prefix math: &lt;</code><a
    href="http://www.w3.org/2000/10/swap/math"><code>http://www.w3.org/2000/10/swap/math</code></a>#<code>
    &gt;</code> .</p>

    <h3>String</h3>

    <p>Simple string functions</p>

    <p><code>@prefix string: &lt;</code><a
    href="http://www.w3.org/2000/10/swap/string"><code>http://www.w3.org/2000/10/swap/string</code></a><code>
    #&gt;</code> .</p>

    <h3>Operating system interface</h3>

    <p>Command line arguments after a --with argument are passed to
    the cwm rules and available though os:argv. Also os:environ
    allows access to environment variables.</p>

    <p><code>@prefix os: &lt;</code><a
    href="http://www.w3.org/2000/10/swap/math"><code>http://www.w3.org/2000/10/swap/os</code></a><code>
    #&gt;</code> .</p>

    <h3>Cryptography</h3>

    <p>For security, check the signatures on information before you
    trust it. All you need to build a secure system - but ask a
    security expert to check your system before you really rely on
    it: good security has to be learned.</p>

    <p>@prefix cr: &lt;<a
    href="../../../10./swap/crypto">http://www.w3.org/2000/10/swap/crypto</a>#&gt;.</p>

    <p>I am not an expert but a few things to watch are:</p>

    <ul>
      <li>Allways think where the weakest link is. It is not always
      on the net.</li>

      <li>Where do you keep the private key, anyway?</li>

      <li>Beware of all forms of attack, including replay and man
      in the middle.</li>

      <li>Always sign some random junk as well as the critical data
      to stop reverse engineering of the key.</li>

      <li>Ask a crypto specialist to look over your stuff</li>

      <li>Make the techniques, rules, code. public. Public
      debugging is valuable. trying to hide it from attackers by
      keeping it secret doesn't pay.</li>

      <li>This code is not guaranteed anyway, or made for
      production use. It is designed for prototyping new semantic
      web applications. Use at your own risk.</li>
    </ul>
    <hr />

    <h2 id="Python">Python modules</h2>

    <h3>Don't trust the doc</h3>

    <p>The best test of works is what has been tested. So the list
    of files in the <a href="../test/retest.sh">regression test</a>
    defines the set of features which are generally checked on each
    checkin.</p>

    <h3>llyn.py - The Store</h3>

    <p>An in-memory store which does the inference.</p>

    <h3 id="L133">notation3.py - Serializing/deserializaing
    RDF:</h3>

    <p>Originally written by Dan Connolly, uses a basic RDF stream
    parser interface</p>

    <ul>
      <li>Parses N3</li>

      <li>Generates RDF</li>

      <li>Generates N3</li>
    </ul>

    <p>The command line form (alias n3 python notation3.py; n3
    -help) allows RDF to be parsed and re-output.</p>

    <p>The module will also run as a CGI script to convert N3 to
    RDF M&amp;S 1.0 - by DanC magic.</p>

    <ul>
      <li><a href="notation3.py">Source</a></li>
    </ul>

    <h3 id="L311">xml2rdf.py Parsing RDF/XML</h3>

    <p>Based on Python's xmllib, this parser is compatible with the
    RDF stream interface of, notation3.py. It completes the square
    of parsers and generators. <strong>Defunct. Now use sax parser
    and sax2rdf.py.</strong></p>

    <ul>
      <li>Parses RDF</li>
    </ul>

    <p>It has a command line mode for self-test purposes.</p>

    <ul>
      <li><a href="xml2rdf.py">Source</a></li>
    </ul>

    <h3>cwm_xxx.py - builtin modules</h3>

    <p>These are quite easy to add to</p>

    <h2><a id="Design" name="Design">Design issues</a></h2>

    <p>The code above investigated and raised issues discussed in
    the following documents.</p>

    <ul>
      <li><a href="/DesignIssues/Notation3.html">Notation 3 - an
      alternative RDF syntax</a></li>

      <li><a href="/DesignIssues/Anonymous.html">Quantification
      implicit in anonymous nodes</a></li>
    </ul>

    <p>not to mention</p>

    <ul>
      <li>RDFM&amp;S and schema issues</li>

      <li>The question of quoting and BagIDs etc</li>
    </ul>

    <h2><a id="QA" name="QA">Code Review notes</a></h2>

    <p><em>5Aug2002, DanC</em></p>

    <ul>
      <li>relative URI stuff is all over the map. move to
      uripath.py</li>

      <li>why is verbosity() in thing? that seems to be the only
      part of the thing module that llyn uses</li>

      <li>use Namespace() class; N3_forAll_URI = RDFSink.forAllSym
      -&gt; log.forAll</li>

      <li>use subclasses of string, rather than pairs, for terms?
      (ala eikon's rdflib)</li>

      <li>
        python style: 

        <ul>
          <li>would be nice to have module dependency graph, to
          know where to start scrubbing</li>

          <li>scrub modules for python style; (cite the <a
          href="http://www.python.org/doc/essays/styleguide.html">styleguide</a>
          from scrubbed modules) benefit: nice pydoc</li>

          <li>start using python's unit test stuff? maybe start
          with uripath.py</li>

          <li>scrub with pychecker? (@@cf. earlier report mailed to
          www-archive)</li>

          <li>is there a __debug__ or some other established
          convention to use in place of verbosity()?</li>
        </ul>
      </li>

      <li>
        open source community style: 

        <ul>
          <li>no README in cwm.tar.Z</li>

          <li>no CHANGES in cwm.tar.Z</li>

          <li>cwm.tar.Z: compress??? er... .tgz, please</li>
        </ul>
      </li>

      <li>this file should be XHTML</li>
    </ul>

    <h2>Acknowledgements</h2>

    <p>Thanks to Dan Connolly for writing the first code and
    introducing me to Python, and to him and Sean Palmer and Mark
    Nottingham for writing code. Thanks to Sean for his <a
    href="http://infomesh.net/2001/cwm/">guide</a> to cwm. Thanks
    for all on #RDFIG for being everything which #RDFIG is.</p>

    <h2 id="Related">Related work</h2>

    <p>See <a href="#Check">above</a></p>

    <h2>Places to talk about this</h2>

    <ul>
      <li>The RDF Interest group</li>

      <li><a href="irc://irc.openprojects.net/rdfig">#RDFIG irc
      channel</a></li>
    </ul>
    <hr />

    <address>
      Tim BL, with his director hat off<br />
       $Id$
    </address>
  </body>
</html>

