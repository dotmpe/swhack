Design of the cwm proof format; and its issues.

 [] :A :B


{ {?A a owl:Thing} => {?A = rdf:nil} }

{ {?B a owl:Thing} => {?B = rdf:nil} }

{:A a owl:Thing}

{:B a owl:Thing}

{ :Yosi :says {:A a owl:Thing} } .



syosi@YOSI:~/SWAP/test/reason$ cwm socrates.n3 --think --base=foo: --why
#Processed by Id: cwm.py,v 1.185 2006/05/30 21:08:05 syosi Exp
        #    using base foo:
              (socrates, type, Mortal)

#  Notation3 generation by
#       notation3.py,v 1.187 2006/01/13 14:48:54 syosi Exp

#   Base was: foo:
     @prefix : <http://www.w3.org/2000/10/swap/reason#> .
    @prefix log: <http://www.w3.org/2000/10/swap/log#> .
    @prefix n3: <http://www.w3.org/2004/06/rei#> .
    @prefix soc: <file:/home/syosi/cvs-trunk/WWW/2000/10/swap/test/reason/socrates.n3#> .

     @forSome <#_g0> .
      [      a :Conjunction,
                    :Proof;
             :component  [
                 a :Inference;
                 :binding  [
                     :boundTo  [
                         n3:uri "file:/home/syosi/cvs-trunk/WWW/2000/10/swap/test/reason/socrates.n3#socrates" ];
                     :variable  [
                         n3:uri "file:/home/syosi/cvs-trunk/WWW/2000/10/swap/test/reason/socrates.n3#who" ] ];
                 :evidence  (
                 [
                         a :Extraction;
                         :because <#_g0>;
                         :gives {soc:socrates     a soc:Man .
                        } ] );
                 :rule  [
                     a :Extraction;
                     :because <#_g0>;
                     :gives { @forAll soc:who .
                    {
                        soc:who     a soc:Man .

                        }     log:implies {soc:who     a soc:Mortal .
                        } .
                    } ] ],
                    <#_g0>;
             :gives { @forAll soc:who .
            soc:socrates     a soc:Man,
                        soc:Mortal .
            {
                soc:who     a soc:Man .

                }     log:implies {soc:who     a soc:Mortal .
                } .
            } ].

    <#_g0>     a :Parsing;
         :because  [
             a :CommandLine;
             :args "['/home/syosi/SWAP/cwm.py', 'socrates.n3', '--think', '--base=foo:', '--why']" ];
         :source <file:/home/syosi/cvs-trunk/WWW/2000/10/swap/test/reason/socrates.n3> .

#ENDS


This is tough to deal with. What do I want?

Parse <file:/home/syosi/cvs-trunk/WWW/2000/10/swap/test/reason/socrates.n3> because of Commandline; get
   F1 = { 
   F1:D1    @forAll soc:who .
   F1:L1    soc:socrates     a soc:Man .
   F1:L2    !F1:F1      log:implies  !F1:F2 .
        } .
   F1:F1 = { 
   F1:F1:L1    soc:who     a soc:Man .       
           } .
   F1:F2 = {
   F1:F2:L1   soc:who     a soc:Mortal .
           } .

F1 implies F2, where
   F2 = {
   F2:L1   soc:socrates     a soc:Man
        }, with F1:L1 -> F2:L1

F1 implies F3 where
   F3 = {
   F3:D1 @forAll soc:who .
   F3:L1    !F3:F1      log:implies  !F3:F2 .
        } .
   F3:F1 = { 
   F3:F1:L1    soc:who     a soc:Man .       
           } .
   F3:F2 = {
   F3:F2:L1   soc:who     a soc:Mortal .
           }, with F1:D1 -> F2:D1, F1:L2 -> F3:L1, F1:F1:L1 -> F3:F1:L1, F1:F2:L1 -> F3:F2:F1

We can apply Modus Ponens with F3 getting the bindings
   soc:who -> soc:socrates.

getting F4 = {
   F4:L1    !F3:F1      log:implies  !F3:F2 .
        } .
   F4:F1 = { 
   F4:F1:L1    soc:socrates     a soc:Man .       
           } .
   F4:F2 = {
   F4:F2:L1   soc:socrates     a soc:Mortal .
           }, with F3:D1 -> soc:socrates, F3:L1 -> F4:L1, F3:F1:L1 -> F4:F1:L1, F3:F2:L1 -> F4:F2:F1

We are left with an antecedent of F4:F1, and a consequent of F4:F2

F2 implies F4:F1, with F2:L1 -> F4:F1:L1
Thus, we now know 
 F5 = F4:F2

F1 and F4 combine to form 
F6 = { 
   F6:D1    @forAll soc:who .
   F6:L1    soc:socrates     a soc:Man .
   F6:L2    soc:socrates     a soc:Mortal .
   F6:L3    !F1:F1      log:implies  !F1:F2 .
        } .
   F6:F1 = { 
   F6:F1:L1    soc:who     a soc:Man .       
           } .
   F6:F2 = {
   F6:F2:L1   soc:who     a soc:Mortal .
           }, with F1:D1 -> F6:D1, F1:L1 -> F6:L1, F5:L1 -> F2:L2, F1:L2 -> F6:L3, F1:F1:L1 -> F6:F1:L1, F1:F2:L1 -> F6:F2:F1

QED