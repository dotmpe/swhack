@prefix dc: <http://purl.org/dc/elements/1.1/>.

<> dc:title "An RDF/DAML+OIL Schema/Ontology for the XML infoset";
 dc:source <http://www.w3.org/TR/2001/WD-xml-infoset-20010316/>;
 dc:description """I (DanC) am going over the spec again,
 transcribing it to DAML+OIL. So far, I've done
 all the Document properties, and it's going great!
 I've transcribed the sense of the spec using DAML+OIL plus
 just one horn-clause rule.""".

@prefix dpo:  <http://www.daml.org/2001/03/daml+oil#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix : <http://www.w3.org/2001/04/infoset#> .
@prefix w: <w3c-webmaster@@#>.

<> w:nspolicy
"""
This RDF schema's namespace name

 http://www.w3.org/2001/04/infoset#

 will only be used to describe the infoitems and properties defined in
 the corresponding version of the XML Infoset specification, which is

  http://www.w3.org/TR/2001/WD-xml-infoset-20010316

 Any new version of the specification that changes the infoitems or
 properties will have a new RDF schema with a different namespace
 name.

 This RDF schema for the XML Infoset is not a normative part of the 
 XML Infoset Specification.  If this schema is found not to match
 the normative text of the specification, it will be corrected without
 changing the namespace name.
""".

@prefix iu: <infosetUtil#>. #@@?
@prefix dl: <damlList#>. #@@


:Document rdfs:label "Document";
  rdfs:comment "2.1. The Document Information Item";
  rdfs:subClassOf [
    dpo:onProperty :children;
    dpo:toClass iu:DocChildren;
  ];

  rdfs:subClassOf [
    dpo:onProperty :documentElement;
    dpo:toClass :Element;
    ];

  rdfs:subClassOf [
    dpo:onProperty :notations;
    dpo:toClass [ iu:setOf :Notation ]
  ];

  rdfs:subClassOf [
    dpo:onProperty :unparsedEntities;
    dpo:toClass [ iu:setOf :UnparsedEntity ]
  ];

  rdfs:subClassOf [
    dpo:onProperty :baseURI;
    dpo:toClass iu:AbsoluteURI;
  ];

  rdfs:subClassOf [
    dpo:onProperty :systemIdentifier;
    dpo:toClass iu:AbsoluteURI;
  ];

  #@@REVIEW: this should be a property of a parsed entity,
  # not a property of a document.
  rdfs:subClassOf [
    dpo:onProperty :characterEncodingScheme;
    dpo:toClass iu:EncName
  ];

  rdfs:subClassOf [
    dpo:onProperty :standalone;
    dpo:toClass iu:StandAloneType;
  ];

  rdfs:subClassOf [
    dpo:onProperty :version;
    dpo:toClass [ dpo:unionOf (iu:NoValue iu:VersionNum) ]
  ].

iu:DocChildren rdfs:label "Items...";
  iu:listOf [
    dpo:disjointUnionOf (
      :Element # exactly one; see rule below
      :ProcessingInstruction
      :Comment
      :DocumentTypeDeclaration # at most one@@
    ) ].

:Element     rdfs:label "Element";
  rdfs:comment "@@more...".

:ProcessingInstruction rdfs:label "Processing Instruction";
  rdfs:comment "@@more...".

:Comment     rdfs:label "Comment";
  rdfs:comment "@@more...".

:DocumentTypeDeclaration rdfs:label "Document Type Declaration";
  rdfs:comment "@@more...".

:Notation rdfs:label "Notation";
  rdfs:comment "@@more...".

:UnparsedEntity rdfs:label "Unparsed Entity";
  rdfs:comment "@@more...".

:allDeclarationsProcessed iu:propertyName "all declarations processed";
  rdfs:range iu:Boolean.
  

:children iu:propertyName "children".

:documentElement iu:propertyName "document element".

:notations iu:propertyName "notations".

:unparsedEntities iu:propertyName "unparsed entities".

:baseURI iu:propertyName "base URI".

:systemIdentifier iu:propertyName "system identifier".

:characterEncodingScheme iu:propertyName "character encoding scheme".

:standalone iu:propertyName "standalone".
:yes rdfs:label "yes".
:no rdfs:label "no".
:noValue rdfs:label "no value".

### supplemental rules
@prefix log: <http://www.w3.org/2000/10/swap/log.n3#>.

# REVIEW: this is left implicit in the infoset spec.
{ :d a :Document;
     :children [ dl:member :e ].
  :e a :Element
} log:means { :d :documentElement :e. }.


## Infoset Utilities (separate this out?)
iu:propertyName rdfs:subPropertyOf rdfs:label;
  rdfs:label "property name";
  rdfs:comment "section 2. Information Items. @@isDefinedBy?";
  rdfs:domain dpo:UniqueProperty. # all infoset properties are unique/many-to-one/functional.

iu:listOf rdfs:label "list of";
  rdfs:range rdfs:Class.
iu:setOf rdfs:label "set of";
  rdfs:comment "finite set of some class";
  rdfs:range rdfs:Class;
  rdfs:domain iu:Set;
  a dpo:UniqueProperty, dpo:UnambiguousProperty.
iu:Set rdfs:subClassOf rdfs:Bag;
  rdfs:label "Set";
  rdfs:comment "finite set";
  a dpo:UniqueProperty, dpo:UnambiguousProperty.
<> log:forAll :x, :C.
{ :x dl:member [ a [ iu:listOf :C ] ]} log:implies { :x a :C }. #iff rule?@@
{ :x a [ a [ iu:setOf :C ] ]} log:implies { :x a :C }. #iff rule?@@

iu:AbsoluteURI   rdfs:label "Absolute URI";
  rdfs:subClassOf rdfs:Literal;
  rdfs:comment "@@connect with XML Schema data type and/or 03swell/URI stuff".

iu:EncName rdfs:label "EncName";
  iu:pattern "[A-Za-z][A-Za-z0-9._-]*"; #@@ double-check this.
  rdfs:isDefinedBy <http://www.w3.org/TR/REC-xml#NT-EncName>;
  rdfs:comment"production [81] from the XML spec".

iu:VersionNum rdfs:label "VersionNum";
  iu:pattern "[a-zA-Z0-9_.:-]+";
  rdfs:isDefinedBy <http://www.w3.org/TR/REC-xml#NT-VersionNum>.

iu:pattern rdfs:label "pattern";
  rdfs:comment "@@xml schema datatype facet";
  rdfs:domain rdfs:Class.
{ :C iu:pattern :x } log:implies { :C rdfs:subClassOf rdfs:Literal }.

iu:StandAloneType rdfs:label "Standalone Type";
  dpo:oneOf ( :yes :no ).
iu:NoValue rdfs:label "No Value";
  dpo:oneOf ( :noValue ). #@@ cf bottom in KIF v3

## Set utilities...
         
iu:instance dpo:inverseOf rdf:type.

dpo:toClass rdfs:domain rdfs:Class.

# (part of?) the definition of rdfs:domain...
<> log:forAll :s, :p, :o, :C.
{ :s :p :o.
  :p rdfs:domain :C. } log:implies { :s a :C }.

# a theorem: if X subset Y, then PowerSet(X) subset PowerSet(Y)
<> log:forAll :E1, :E2, :C1, :C2, :P, :Q.

{ :C1 is iu:setOf of :C2 }
   log:means { :C1 dpo:onProperty :instance; dpo:toClass :E1 }.
iu:setOf a dpo:UnambiguousProperty.
iu:setOf a dpo:UniqueProperty.
{ :P log:means :Q } log:implies { :P log:implies :Q. :Q log:implies :P. }.

{ :C1 is iu:setOf of :E1.
  :C2 is iu:setOf of :E2.
  :E1 rdfs:subClassOf :E2. }
  log:implies { :C1 rdfs:subClassOf :C2. }.


# explain a bit of daml...
<> log:forAll :C1, :x, :L, :C2.

{ :L dpo:first :x } log:implies { :L dl:member :x }.
{ :L dpo:rest [ dl:member :x ] } log:implies { :L dl:member :x }.

{ :C1 dpo:disjointUnionOf :L.
  :L dl:member :C2 }
  log:implies { :C2 rdfs:subClassOf :C1 }.

dpo:oneOf rdfs:domain rdfs:Class.

{ :C1 dpo:oneOf :L.
  :L dl:member :x.
}
  log:implies { :x a :L }.

# some rdfs rules...
<> log:forAll :s, :p, :o, :p2.
{ :s :p :o.
  :p rdfs:subPropertyOf :p2 }
log:implies { :s :p2 :o }.

 #ENDS
