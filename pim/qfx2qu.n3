#  n3
# 
#  Convert new OFX concepts back to old boring QIF ones
#
#  This takes the output of (for example) qfx2n3.py - an OFX-standard
# file except in N3 format (.ofx3), and it generates a series of transaction
# in a much simpler format rather like the old quicken interchange format (.qu3).
#
#  Actually reverse makes more sense as modelling is much better - this
# way removes information.  The .ofx3 file is a self-describing statement.
#
#  This invents URIs for bank accounts and transactions, so that other files
# can easily refer to them, and different statements will refer to the
# same bank account easily.
#
# Example Makefile extract to convert downloaded .ofx files:
#.ofx.ofx3:
#	sed -f $(PIM)/qfx2n3.sed < $< > $@
#.ofx3.qu3:
#	$(CWM) $< -apply=qfx2qu.n3 -apply=qfx2qu.n3 --purge > $@

@prefix log: <http://www.w3.org/2000/10/swap/log#>.
@prefix s: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix crypto: <http://www.w3.org/2000/10/swap/crypto#>.
@prefix string: <http://www.w3.org/2000/10/swap/string#>.
@prefix math: <http://www.w3.org/2000/10/swap/math#>.
@prefix os: <http://www.w3.org/2000/10/swap/os#>.
@prefix qu:  <http://www.w3.org/2000/10/swap/pim/qif#>.

# QFX (OFX) format:
@prefix ofx: <http://www.w3.org/2000/10/swap/pim/ofx#> .
@prefix ofxh: <http://www.w3.org/2000/10/swap/pim/ofx-headers#> .
#

@prefix : <var#>.

this log:forAll :a, :b, :d, :i, :l, :m, :n, :p, :r, :s, :t, :x, :y, :z.



########## Rule for getting credit card account:
#
# Bug: does not pick up any name for the account.
# I guess this is to do with the way credit cards work: they are not really
# connected to  a bank as they can be transferred from bank to bank.
# could use last 4 digits of card number

{
:s ofx:OFX  [

#   ofx:SIGNONMSGSRSV1[
#       ofx:SONRS[
#        ofx:DTSERVER "2005-09-01T08:54:01";
#        ofx:LANGUAGE "ENG";
#        ofx:DTACCTUP "20050901085401.000[-4:EDT]";
#        ofx:FI[
#            ofx:ORG ?f ;      #          e.g. "Bank of America";
#            ofx:FID "BANK OF AMERICA";
#              ];   # FI
#	];   # SONRS
#    ];   # SIGNONMSGSRSV1
	    
	
   ofx:CREDITCARDMSGSRSV1[
       ofx:CCSTMTTRNRS  [
           ofx:CCSTMTRS  [
               ofx:CCACCTFROM  [
                   ofx:ACCTID :a;
#                   ofx:ACCTTYPE :l;
#                   ofx:BANKID :b
	       ];
               ofx:BANKTRANLIST :x
                        ]]]].

# Construct a unique identifier for account which will match
# between different statements:

    (:a ".*(....)") string:scrape ?a4. # Last 4 digits only
    :z 	log:uri [is os:baseAbsolute of
		    [is string:concatenation of ( "acc#CCARD_" ?a4 )]].
	
} log:implies {
   :x	:listForAccount :z;
	:payeeField ofx:NAME;   # New version
	:sourceDocument :s.
	
   :z   ofx:ACCTID :a4;
	 # Extending their ontology by inventing an account type for consistency
	 # :-/
        ofx:ACCTTYPE "CREDITCARD";  s:label "CREDITCARD";
#        ofx:BANKID :b.
}.



############### POST 2005 rule for finding responses - bank version:

{
:s ofx:OFX  [
   ofx:BANKMSGSRSV1[
       ofx:STMTTRNRS  [
           ofx:STMTRS  [
               ofx:BANKACCTFROM  [
                   ofx:ACCTID :a;
                   ofx:ACCTTYPE :l;
                   ofx:BANKID :b ];
               ofx:BANKTRANLIST :x
                        ]]]].

# Construct a unique identifier for account which will match
# between different statements:

    :z 	log:uri [is os:baseAbsolute of
		    [is string:concatenation of ( "acc#" :b "_" :a )]].
	
} log:implies {
   :x	:listForAccount :z;
	:payeeField ofx:NAME;   # New version
	:sourceDocument :s.
   :z   ofx:ACCTID :a;
        ofx:ACCTTYPE :l;  s:label :l;
        ofx:BANKID :b.
}.


########### ORIGINAL pre-2005-06 rule: 
{
:s ofx:OFX  [
   ofx:BANKMSGSRSV1[
       ofx:STMTTRNRS  [
           ofx:STMTTRN  [    # sic. Later becomes STMTTRS. Maybe was Fleet bug.
               ofx:BANKACCTFROM  [
                   ofx:ACCTID :a;
                   ofx:ACCTTYPE :l;
                   ofx:BANKID :b ];
               ofx:BANKTRANLIST :x
                        ]]]].

# Construct a unique identifier for account which will match
# between different statements:

    :z 	log:uri [is os:baseAbsolute of
		    [is string:concatenation of ( "acc#" :b "_" :a )]].
	
} log:implies {
   :x	:listForAccount :z;
	:payeeField ofx:MEMO;  # Old version
	:sourceDocument :s.
	
   :z   ofx:ACCTID :a;
        ofx:ACCTTYPE :l;  s:label :l;
        ofx:BANKID :b.
}.


###################### Now we have isolated the statement list

# Convert statements to basic financial ontology
#
# We use NAME as that is what there is, whil before
# we used MEMO which was in practice a longer version of NAME.

{  [:listForAccount :y; :payeeField ?p; :sourceDocument :s] ofx:STMTTRN
  [
   ofx:DTPOSTED :d;
   ofx:FITID    :i;
   ?p           :m;
   ofx:TRNAMT   :x ].
   :i crypto:sha ?id.
   :r log:uri [is os:baseAbsolute of
	[is string:concatenation of ( "fit.n3#" ?id  )]].
#   ofx:TRNTYPE  :t 
} log:implies {
:r  qu:toAccount :y ;
   qu:date :d;
   qu:payee :m;  	# Quicken seems to mix it like this
   qu:accordingTo :s;	# useful to track the source
   qu:amount :x .
}.


###############

# For those with check numbers, get the check number:
{  [:listForAccount :y] ofx:STMTTRN [
   ofx:FITID    :i;
   ofx:CHECKNUM   :x ].
   :r log:uri [is os:baseAbsolute of
	[is string:concatenation of ( "fit.n3#" :i  )]].
#   ofx:TRNTYPE  :t 
} log:implies {
:r  qu:number :x .
}.

   

#ends
