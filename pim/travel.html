<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <title>Semantic Web Application Integration: Travel Tools</title>
  <link rel="stylesheet" href="../doc/style.css" />
<style type="text/css">
.mechanics { background-color: #b6b6b6; }
</style>
</head>

<body>
<div class="noprint">
<a href="../../../../">W3C</a> | <a href="../../../01/sw/">SWAD</a> | <a
href="../">SWAP</a> | <a href="../doc/">Tutorial</a>
</div>

<h1>Semantic Web Application Integration: Travel Tools</h1>

<p><em>The bane of my existence is doing things I know the computer
could do for me.</em> When I got my proposed July 2001 travel
itinerary in email, I just couldn't bear the thought of manually
copying and pasting each field from the iterary into my calendar.  I
started putting the Semantic Web approach to application integration
to work.</p>

<p>The Semantic Web approach to application integration emphasizes
data about real-world things like people, places, and events over
document structure. Documents are important real-world things too, of
course. And Semantic Web data formats benefit from the
internationalization support in XML and the growing infrastructure of
tools. But most XML schemas are too constrained, syntactically, and
not constrained enough, semantically, to accomplish these integration
tasks:</p>

<ul>
<li><a href="#map-viz">plot an itinerary on a map</a></li>
<li><a href="#ical-evo">import travel itineraries into my iCalendar-happy desktop PIM</a></li>
<li><a href="#plain-text-sum">produce a brief summary of an itinerary for use in plain text email</a></li>
<li><a href="#ckcn">check proposed work travel itineraries against family constraints</a></li>
<li><a href="#pda-in">import travel itineraries into my PDA calendar</a></li>
<li>tell me when my travel schedule brings me unusually near a friend/colleague</li>
<li>produce animated views of my travel schedule or past trips</li>
<li>find conflicts between teleconferences and flights</li>
</ul>


<h2 id="grokLeg">Working with legacy data</h2>

<p>While more and more of the data in our lives is available
in the Semantic Web, there will always be a place for mechanisms
that extract the statements implicit in legacy data.</p>

<p>The data comes from the travel agency like this, probably
dumped from their database system:</p>

<pre>07 APR 03 - MONDAY
AIR AMERICAN AIRLINES FLT:3199 ECONOMY
OPERATED BY AMERICAN AIRLINES
LV KANSAS CITY INTL 940A EQP: MD-80
DEPART: TERMINAL BUILDING B 01HR 36MIN
AR DALLAS FT WORTH 1116A NON-STOP</pre>

<p>I hope that before too long they'll dump it from their
database directly into RDF
or perhaps in XML using some travel industry vocabulary, but</p>

<ul>

<li>before they'll do so, somebody will have to show them why it's
valuable</li>

<li>sometimes, for the short term, reverse-engineering the structure
of their data is cheaper than getting them to change their
processes</li>

</ul>

<p>So I wrote a perl script (<a
href="/2001/07dc-bos/grokNavItin.pl">grokNavItin.pl</a>) to extract
statements from the data:</p>

<p><img src="grokLeg.png" alt="itin.txt -&gt; itin.n3/rdf" /></p>

<p>The output of the perl script, <tt>itin.nt</tt>,
is in <a
href="http://www.w3.org/TR/rdf-testcases/#ntriples">n-triples</a>, a
line-oriented serialization developed in the RDF Core working group
for testing parsers. For visual inspection and debugging, we use cwm
to pretty-print it in N3. The result look like this:</p>

<pre>
    :_gflt3199_3     a :_gECONOMY_5;
         k:endingDate :_gdayMONDAY07_2;
         k:fromLocation &lt;http://www.daml.org/cgi-bin/airport?MCI&gt;;
         k:startingDate :_gdayMONDAY07_2;
         k:toLocation &lt;http://www.daml.org/cgi-bin/airport?DFW&gt;;
         t:arrivalTime "11:16";
         t:carrier :_gAMERICANAIRLINES_4;
         t:departureTime "09:40";
         t:flightNumber "3199" .

    :_gAMERICANAIRLINES_4     a k:AirlineCompany;
         k:nameOfAgent "AMERICAN AIRLINES" .
    
    :_gECONOMY_5     r:value "ECONOMY" .

    :_gdayMONDAY07_2     a k:Monday;
         dt:date "2003-04-07" .
    

</pre>

<h3>Choosing a Vocabulary: Build Or Buy?</h3>


<p>The import script not only bridges the syntactic
gap between the legacy data and RDF, but it also translates
the vocabulary of terms used in the data into URI space.
This raises the classic build-or-buy choice:</p>

<dl>
<dt>use (buy) an existing, general-purpose vocabulary</dt>

<dd>If we can accept the risk of putting word's into the source's
mouth, we can benefit from an economy of scale of shared vocabulary
such as the <a
href="http://www.cyc.com/cyc-2-1/vocab/transportation-vocab.html">cyc
ontology of common sense transportation terms</a>.</dd>

<dt>build a vocabulary just for this purpose</dt>
<dd>A special-purpose vocabulary isolates the data
from risks of version skew and such.</dd>
</dl>

<p>Early versions of the import script used a special-purpose
vocabulary; rules to relate this vocabulary to other
vocabularies were developed one at a time. But eventually
a pattern of using the general purpose cyc ontology
emerged, and the expected benefit of maintaining the
special-purpose ontology was dominated by the cost.
More recent versions convert directly to terms
in shared ontologies, except in the case where
custom terms were needed:</p>

<div align="center"><img alt="travel terms" src="travelFig.png" />

<div class="noprint mechanics" >if your desktop is SVG-happy, <a href="travelFig.svg">travelFig.svg</a> is
nicer. I drew it with dia; you can play <a
href="travelFig.xml">travelFig.xml</a>, the source. I'm working on <a
href="/2002/03owlt/umlp/dia2owl.xsl">dia2owl.xsl</a>, which converts it to
RDF/S: <a href="travelFig.rdf">travelFig.rdf</a>.
</div>
</div>


<ul>
<li style="color: red">cyc terms (prefix <tt>k:</tt>) in red</li>
<li style="color: purple">DAML airport ontology terms in purple</li>
<li style="color: green">custom travelTerms (prefix <tt>t:</tt>) in green.
e.g. <code>departureTime</code>, <code>flightNumber</code>, ...; see <a
href="travelTerms">travelTerms</a>, in <a href="travelTerms.rdf">RDF/xml</a>,
<a href="travelTerms.rdf">RDF/n3</a>.
</li>
<li style="color: blue">RDF standard terms (prefix <tt>r:</tt>)in blue</li>
<li style="color: orange">XML Schema terms (prefix <tt>dt:</tt>)in orange</li>
</ul>

<p>Note that <strong>mixing vocabularies in RDF is easy</strong>; so
easy, compared with the general problem of mixing XML namespaces, that
I hardly notice it at all. Within the basic subject/predicate/object
abstract syntax, terms can be combined freely. Migrating to more
specialized or more generalized terms is cheap, using
<tt>rdfs:subPropertyOf</tt> and the like.</p>

<div class="noprint"> <em>(@@ok to just say that
without demonstrating it?)</em></div>

<h2 id="map-viz">Integration with mapping tools</h2>

<p>Let's exploit the effort we have put into going beyond formalized
document structure into formalized data about the real world.
Folks in the <a href="http://www.daml.org/">DAML project</a> have
imported airport lat/long data into the semantic web; we
can use log:semantics to reach out and get it with rules like
these, excerpted from <a href="airportLookup.n3">airportLookup.n3</a>:
</p>

<pre>
# well-known airports...
{ :X a :Y; #@@kludge...
    log:uri [ str:startsWith "http://www.daml.org/cgi-bin/airport?" ] }
 log:implies { :X a :AirportKnownToDAML }.

{ :X apt:iataCode :K.
  :Y log:uri [ is str:concatenation of
               ("http://www.daml.org/cgi-bin/airport?" :K) ];
}
  log:implies { :Y a apt:Airport; apt:iataCode :K; = :X }.

# we only want to look up certain airports...
{ [ k:toLocation :X ]. }
 log:implies { :X a :InterestingPlace }.
{ [ k:fromLocation :X ]. }
 log:implies { :X a :InterestingPlace }.


# believe what daml.org says about airport latitutde/longitudes...
:AirportProperty is rdf:type of
  apt:latitude,
  apt:name,
  apt:iataCode,
  apt:icaoCode,
  apt:location,
  apt:latitude,
  apt:longitude,
  apt:elevation.

{
  :P a :AirportProperty.
  [ a :AirportKnownToDAML, :InterestingPlace;
    log:semantics [
      log:includes {
        :IT :P :X.
      }
    ] ].
} log:implies {
  :IT a apt:Airport; :P :X.
}.
</pre>


<p>For the convenience of consumers (including ourselves), we publish
in RDF/XML the results of reaching out with the rules; i.e. the
itinerary including the lat/long info. Then we use the (<em>little
documented</em>) <tt>cwm --strings</tt> output mode to generate two
files, <tt>itin-arcs</tt> and <tt>itin-markers</tt>, as input to <a
href="http://xplanet.sourceforge.net/">xplanet</a>:</p>

<div class="figure" align="center">

<img alt="map viz toolchain" src="mapVizFig.png" />
</div>


<p>The resulting map shows that we have given the
machine a fairly deep understanding of the itinerary:</p>

<div class="figure" align="center">

<p><img alt="MCI to YMX and back for Extreme 2002"
src="../../../../2003/04dc-mia/itin-mia.png" /></p>

<div class="noprint mechanics">more details are in the <a href="../../../../2003/04dc-mia/Makefile">Makefile</a></div>
</div>



<h2 id="ical-evo">Integration with iCalendar Tools</h2>

<p>In fact, the published RDF/XML version of the itinerary is joined
not only with latitude/longitude data, but also timezone data, and
elaborated via <a href="itin2ical.n3">itin2ical.n3</a> rules into <a href="../../../../2002/12/cal/">an RDF
representation of the standard iCalendar syntax</a>.</p>

<pre>

{ :FLT
    k:startingDate [ dt:date :YYMMDD];
    k:endingDate [ dt:date :YYMMDD2];
    t:departureTime :HH_MM;
    k:fromLocation [ :timeZone [ cal:tzid :TZ] ];
    t:arrivalTime :HH_MM2;
    k:toLocation [ :timeZone [ cal:tzid :TZ2] ].
  :DTSTART is str:concatenation of
    (:YYMMDD "T" :HH_MM ":00"). #@@ extra punct in dates
  :DTEND is str:concatenation of
    (:YYMMDD2 "T" :HH_MM2 ":00").

  ( :FLT!log:rawUri "@uri-2-mid.w3.org") str:concatenation :UID. #@@hmm... kludge?
}
 log:implies {
  :FLT a cal:Vevent;
    cal:uid :UID;
    cal:dtstart [ cal:tzid :TZ; cal:dateTime :DTSTART ];
    cal:dtend [ cal:tzid :TZ2; cal:dateTime :DTEND ].
}.
</pre>


<p> The final
syntactic export is more complex than the markers/arcs case, so we
wrote a python program, <tt><a
href="toIcal.py">toIcal.py</a></tt>, using the
cwm API, to generate iCalendar syntax.</p>

<div class="figure" align="center">
<img alt="calendar integration toolchain" src="calIntFig.png" />
</div>

<p>We can import the resulting iCalendar file into an of
a number of interoperable tools, such as Ximian Evolution:</p>

<div class="figure" align="center">
<img alt="evo screenshot" src="calIntShot.png" />
</div>


<h2 id="plain-text-sum">Plain Text Summaries</h2>

<p>All this rich integration is great when the tools are all working
and you have plenty of bandwidth and all that, but sometimes, plain
text is necessary and sufficient for the task at hand. For example, if
I get mail asking when I arrive at the meeting site, mailing back a
map is probably overkill, and I can't be 100% sure their desktop is
iCalendar-happy.</p>

<p>The <tt>cwm --strings</tt> output mode can
be really handy in these cases; we can use a few
<a href="../../../../2002/10dc-uk/itinBrief.n3">itinBrief.n3</a> rules
ala...</p>

<pre>python cwm.py itinBrief.n3 itin.nt --think --strings</pre>

<p>to get a summary ala...</p>

<pre>
2003-04-07 09:40 - 11:16 MCI->DFW Monday AMERICAN AIRLINES #3199
2003-04-07 12:03 - 15:49 DFW->MIA Monday AMERICAN AIRLINES #68
2003-04-10 19:12 - 21:32 MIA->ORD Thursday AMERICAN AIRLINES #1477
2003-04-10 22:33 - 23:54 ORD->MCI Thursday AMERICAN AIRLINES #1081
</pre>


<h2 id="ckcn">Checking Constraints</h2>

<p>Now that I have the proposed itinerary formalized, I can
automatically check it against various constraints before
I accept it and before I copy it to my PDA and to all the
other peers that need to know about it.</p>

<p>Rules like "itineraries that have me leaving
before 30 July are no good" are a bit tedious to
formalize, but my confidence in the results is
higher than my confidence in eyeballing it:</p>

<pre>{
 ?D a k:ItineraryDocument; k:containsInformationAbout-Focally ?TRIP.
 ?TRIP k:subEvents
    [ k:startingDate [ dt:date ?D1 ];
      k:fromLocation [ apt:iataCode "MCI" ];
      t:departureTime ?T1;
    ].
  ?D1 str:lessThan "2001-07-30".
} => {
   ?TRIP &lt;#leavesDaysTooSoon&gt; ?D1;
          &lt;#at&gt; ?T1.
}.</pre>

<p>These constraints can be checked with cwm ala:</p>

<pre>$ python cwm.py proposed-itinerary.nt --think=constraints.n3</pre>

<p>... and look for <tt>&lt;#leavesDaysTooSoon&gt;</tt> in the output.</p>

<div class="noprint mechanics">
<p>More details: <a href="../../../../2001/08swws67/">SWWS stuff</a>.</p>
</div>

<h2 id="pda-in">Conversion for PDA import</h2>

<p>Having already developed <a
href="http://dev.w3.org/cvsweb/2001/palmagent/">palmagent</a>, an
HTTP/RDF interface to my PDA, it was almost trivial to write some 
rules to relate this itinerary vocabulary to the <a
href="../../../08/palm56/datebook">RDF vocabulary for the palmpilot
datebook</a>:</p>

<div class="figure" align="center">
<img src="travelPdaRulesFig.png" alt="pda rules toolchain" />

<div class="noprint mechanics">see <a
href="../../../../2001/07dc-bos/Makefile">Makefile</a> for (some of
the?) details).  The rules, <a
href="../../../../2001/07dc-bos/itin2datebook.n3">itin2datebook.n3</a>,
use some outdated vocabulary.
</div>

</div>


<div class="noprint"><em>[@@TODO: image of palm pilot showing flight
in the datebook]</em></div>


<div class="noprint">
<hr />
<h2>Fodder</h2>

<h2>Steps Toward Synchronization</h2>

<p>@@"if it's in my HTML schedule but not in evo, print it out in evo format
for import".</p>

<p>Diagram with more stuff: socialParticipants, eventOccursAt, etc.</p>

<p>details from <a href="/2002/08dc-ymx/Makefile">Makefile</a>:</p>

<p>First, scrape a formal version of my HTML schedule:</p>
<pre>status-formal.rdf: $(TEAM)/connolly.html $(SW)/schedScrape.xsl
   $(XSLTPROC) --novalid $(SW)/schedScrape.xsl $(TEAM)/connolly.html &gt;$@</pre>

<p>Then, convert evo ical to RDF:</p>
<pre>,evocal.rdf: $(HOME)/evolution/local/Calendar/calendar.ics $(PIM)/ical2rdf.pl
$(PERL) $(PIM)/ical2rdf.pl $(HOME)/evolution/local/Calendar/calendar.ics &gt;$@</pre>

<p>Finally, check rules ala:</p>
<pre>evoMissing.n3: status2evo.n3 status-formal.rdf ,evocal.rdf
   $(PYTHON) $(CWM) status2evo.n3 --think &gt;$@</pre>

<p>The rules look like <em>[@@TODO: update ical names w.r.t.
capitalization]</em>:</p>
<pre>{
  :P s:subPropertyOf :cityName.
&lt;status-formal.rdf&gt; log:semantics [
  log:includes {
    :E r:value :WHAT;
      k:socialParticipants [ con:mailbox &lt;mailto:connolly@w3.org&gt; ];
      k:eventOccursAt [ :P :CITYNAME; ];
      k:startingDate [ dt:date :START ];
      k:endingDate [ dt:date :END ];
    
  }].

  # ... date conversion stuff...

   &lt;,evocal.rdf&gt; log:semantics [ log:notIncludes {
     [ ical:DTSTART [ ical:DATE :STARTi ];
       ical:DTEND   [ ical:DATE :ENDi ];
       ical:LOCATION :CITYNAME;
     ]
   }].
} log:implies {
   :SyncInfo :eg
     [ ical:DTSTART [ ical:DATE :STARTi ];
       ical:DTEND   [ ical:DATE :ENDi ];
       ical:LOCATION :CITYNAME;
       ical:UID :UID;
       ical:DTSTAMP :STAMP;
     ]
}.</pre>

<h2>Earlier work</h2>
<ol>
  <li><a href="../../atrip/Makefile">Oct 2000 Makefile</a> - n3 to RDF via
    cwm, RDF to HTML via XSLT. some palm datebook integration.</li>
  <li><a href="/2002/01dc-nj/notes">Jan 2002 NJ WebOnt trip</a>. <a
    href="/2002/01dc-nj/itin2ical.n3">rules</a>, <a
    href="http://lists.w3.org/Archives/Public/www-rdf-calendar/2002Jan/0002.html">iCal/evo
    interop</a></li>
  <li><a href="grokItinTable.xsl">grokItinTable.xsl</a> - convert AA.com
    travel itinerary from (tidied) HTML to RDF</li>
  <li><a href="/Talks/2002/10/09-swcal/all.htm">travel tools presentation</a>
    at calendaring workshop</li>
  <li><a href="/2002/10dc-uk/">Bristol trip stuff</a> Oct 2002
  </li>
  <li><a href="/2001/08swws67/">SWWS: An RDF Calendar Trial</a>, Aug 2001.
    pathcross and such.</li>
</ol>

<h2>Related work</h2>
<ul>
  <li><a href="http://www.daml.org/2001/06/itinerary/">DAML itinerary</a> 
    <p>hmm... flight numbers are numbers, not strings. interesting...</p>
  </li>
  <li>rdf-calendar forum@@</li>
  <li>python/evolution stuff: <a
    href="http://heddley.com/edd/2002/03/05/evocal.py">evocal.py</a> from
    Edd. relies on debian package: evolution-dev. also: <a
    href="http://heddley.com/edd/2002/03/05/python-libversit-0.1.tar.gz">python-libversit</a></li>
  <li>'<a
    href="http://lists.w3.org/Archives/Public/www-archive/2002Jun/0014">interview</a>'
    in #rdfig 12Jun</li>
  <li><a href="http://www.cyc.com/cycdoc/vocab/transportation-vocab.html">cyc
    transportation vocab</a></li>
  <li>lat/long source: <a
    href="http://www.un.org/Depts/unsd/demog/ctry.htm">Capital cities and
    cities of 100,000 and more inhabitants</a>; scraped it in <a
    href="../../../04/mem-news/teamToGlobe.n3">team2Globe.n3</a>; hmm...
    seems to cite NIMA's <a
    href="http://www.nima.mil/gns/html/index.html">GEOnet Names Server</a> as
    its source.</li>
</ul>


<p>Some principles:</p>

<blockquote>
  <ul>
    <li>data that isn't consumed rots. 
      <p>ergo</p>
    </li>
    <li>model only those distinctions that you can exploit.</li>
  </ul>
  <address>
    -- <a
    href="http://lists.w3.org/Archives/Public/www-rdf-calendar/2001Jul/0001.html">me,
    Jul 2001 to rdf-calendar</a>
  </address>
</blockquote>

<p>Possible venues to announce this work:</p>
<ul>
  <li>www-rdf-calendar</li>
  <li>dia development list</li>
  <li>WebOnt (interested in UML/OWL)</li>
  <li>www-rdf-interest (for RDFS/UML stuff)</li>
  <li>IETF calsched WG (working on XML versions of ical)</li>
</ul>

<ol>
  <li>I'd probably make a mistake, so I'd never trust the results. I'd always
    have to check the travel itinerary again. <em>Never mind the fact that I
    can't make and follow links from calendar entries to mail messages;
    that's for another day...</em></li>
  <li>I might not agree to the proposed itinerary, in which case I'd have to
    decline it and start over when the revision comes in. I might just be
    able to key in the diffs, but that's even more error prone.</li>
</ol>
</div>

<div class="noprint">
<hr />
<address>
  <p><a href="../../../../People/Connolly/">Dan Connolly</a>, Jun 2002<br />
  $Revision$ of $Date$ by $Author$</p>

</address>
</div>
</body>
</html>
