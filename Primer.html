<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Primer - Getting into the semantic web and RDF using N3</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <link href="/People/Berners-Lee/general.css" rel="stylesheet"
  type="text/css" />
</head>

<body xml:lang="en" lang="en">
<p><a href="/">W3C</a> | <a href="/2000/01/sw/Overview.html">Semantic Web</a>
| <a href="Overview.html">SWAP</a></p>
<br />
<br />


<h1>Primer: Getting into RDF &amp; Semantic Web using N3</h1>
<br />
<br />


<p>The world of the semantic web, as based on RDF, is really simple at the
base. This article shows you how to get started. It uses a simplified
teaching language -- Notation 3 or N3 -- which is basically equivalent to RDF
in its XML syntax, but easier to scribble when getting started.</p>

<h2 id="L553">Subject, verb and object</h2>

<p>In RDF, information is simply a collection of statements, each with a
subject, verb and object - and nothing else. In N3, you can write an RDF
triple just like that, with a period:</p>
<pre>&lt;#pat&gt; &lt;#knows&gt; &lt;#jo&gt; .
</pre>
<br />
<br />


<p>Everything, be it subject, verb, or object, is identified with a Universal
Resource Identifier. This is something like &lt;http://www.w3.org/&gt; or
&lt;http://www.w3.org/2000/10/swap/test/s1.n3#includes&gt;, but when
everything is missed out before the "#" it identifies &lt;#pat&gt; in the
current document whatever it is.</p>

<p>There is one exception that the object (only) can be a string representing
a value:</p>
<pre>&lt;#pat&gt; &lt;#knows&gt; &lt;#jo&gt; .
&lt;#pat&gt; &lt;#age&gt; "24" .
</pre>

<p>The verb "knows" is in RDF called a "property" and thought of as a noun
expressing a relation between the two. In fact you can write</p>
<pre>&lt;#pat&gt; &lt;#child&gt; &lt;#al&gt; .
</pre>

<p>alternatively, to make it more readable, as either</p>
<pre>&lt;#pat&gt; has &lt;#child&gt; &lt;#al&gt; .
</pre>

<p>or</p>
<pre>&lt;#al&gt; is &lt;#child&gt; of &lt;#pat&gt; .
</pre>

<p>There are two shortcuts for when you have several statements about the
same subject: a semicolon ";" introduces another property of the same
subject, and a comma introduces another object with the same predicate and
subject.</p>
<pre>&lt;#pat&gt; &lt;#child&gt;  &lt;#al&gt;, &lt;#chaz&gt;, &lt;#mo&gt; ;
       &lt;#age&gt;    "24" ;
       &lt;#eyecolor&gt; "blue" .
</pre>

<p>So, for example, the data in the table</p>

<table border="1" align="center">
  <tbody>
    <tr>
      <td></td>
      <td>age</td>
      <td>eyecolor</td>
    </tr>
    <tr>
      <td>pat</td>
      <td>24</td>
      <td>blue</td>
    </tr>
    <tr>
      <td>al</td>
      <td>3</td>
      <td>green</td>
    </tr>
    <tr>
      <td>jo</td>
      <td>5</td>
      <td>green</td>
    </tr>
  </tbody>
</table>

<p>could be written</p>
<pre>  &lt;#pat&gt;   &lt;#age&gt; "24";  &lt;#eyecolor&gt; "blue" .
  &lt;#al&gt;    &lt;#age&gt;  "3";  &lt;#eyecolor&gt; "green" .
  &lt;#jo&gt;    &lt;#age&gt;  "5";  &lt;#eyecolor&gt; "green" .
</pre>

<p>Sometimes there are things involved in a statement don't actually have any
identifier you want to give them - you know one exists but you only want to
give the properties . You represent this by square brackets with the
properties inside.</p>
<pre>&lt;#pat&gt; &lt;#child&gt; [ &lt;#age&gt; "4" ] , [ &lt;#age&gt; "3" ].
</pre>

<p>You could read this as #pat has a #child which has #age of "4" and a
#child which has an #age of "3". There are two important things to
remember</p>
<ul>
  <li>The identifiers are just identifiers - the fact that the letters p a t
    are used doesn't tell anyone or any machine that we are talking about
    anyone whose name is "Pat" -- unless we say &lt;#pat&gt; &lt;#name&gt;
    "Pat". The same applies to the verbs - never take the actual letters c h
    i l d as telling you what it means - we will find out how to do that
    later.</li>
  <li>The square brackets declare that something exists with the given
    properties, but don't give you a way to refer to it elsewhere in this or
    another document.</li>
</ul>

<p>If we actually want to use a name, we could have written the table above
as</p>
<pre>  [ &lt;#name&gt; "Pat"; &lt;#age&gt; "24";  &lt;#eyecolor&gt; "blue"  ].
  [ &lt;#name&gt; "Al" ; &lt;#age&gt;  "3";  &lt;#eyecolor&gt; "green" ].
  [ &lt;#name&gt; "Jo" ; &lt;#age&gt;  "5";  &lt;#eyecolor&gt; "green" ].
</pre>

<p>There are many ways of combining square brackets - but you can figure that
out from the examples later on. There is not much left learn about using N3
to express data, so let us move on.</p>

<h2 id="Sharing">Sharing concepts</h2>

<p>The semantic web can't define in one document what something means. That's
something you can do in english (or occasionally in math) but when we really
communicate using the concept "title", (such in a library of congress catalog
card or a web page), we rely on a shared concept of "title". On the semantic
web, we share quite precisely by using exactly the same URI for the concept
of title.</p>

<p>I could try to give the title of an N3 document by</p>
<pre>&lt;&gt; &lt;#title&gt;  "A simple example of N3".
</pre>

<p>(The &lt;&gt; being an empty URI reference always refers to the document
it is written in.) The &lt;#title&gt; refers to the concept of #title as
defined by the document itself. This won't mean much to the reader. However,
a group of people created a list of properties called the <a
href="http://purl.oclc.org/dc/">Dublin Core</a>, among which is their idea of
title, which they gave the identifier</p>

<p>&lt;http://purl.org/dc/elements/1.1/title&gt;. So we can make a much
better defined statement if we say</p>
<pre>&lt;&gt; &lt;http://purl.org/dc/elements/1.1/title&gt;
 "Primer - Getting into the Semantic Web and RDF using N3".
</pre>

<p>That of course would be a bit verbose - imagine using such long
identifiers for everything like #age and #eyecolor above. So N3 allows you to
set up a shorthand prefix for the long part. This is called a namespace
identifier, and you set it up using "@prefix" like this:</p>
<pre>@prefix dc:  &lt;http://purl.org/dc/elements/1.1/&gt; .
&lt;&gt; dc:title  "Primer - Getting into the semantic web and RDF using N3".
</pre>

<p>Note that when you use a prefix, you use a colon instead of a hash between
dc and title, and you don't use the &lt;angle brackets&gt; around the whole
thing. This is much quicker. This is how you will see and write almost all
your predicates in N3. Once set up, a prefix can be used for the rest of the
file (* may change).</p>

<p>There are an increasingly large number of RDF vocabularies for you to
refer to - check the <a href="/RDF/">RDF home page</a> and things linked from
it - and you can build your own for your own applications very simply.</p>

<p>From now, on we are going to use some well known namespaces, and so to
save space, I will just assume the prefixes</p>
<pre>@prefix rdf:  &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .
@prefix ont:  &lt;http://www.daml.org/2001/03/daml-ont#&gt; .
</pre>

<p>These are the RDF, RDF schema, and experimental DAML ontology namespaces,
respectively. They give us the core terms which we can bootstrap ourselves
into the semantic web. I am also going to assume that the empty prefix stands
for the document we are writing, which we can say in N3 as</p>
<pre>@prefix : &lt;#&gt; .
</pre>

<p>This means we could have the example above as</p>
<pre>:pat :child [ :age "4" ] , [ :age "3" ].
</pre>
<br />
<br />


<p>which is slightly less characters to type. Now you understand how to write
data in N3, you can start making up your own vocabularies, because they are
just data themselves.</p>

<h2>Making vocabularies</h2>
<br />
<br />


<p>Things like dc:title above are RDF <dfn><a id="Properties"
name="Properties">Properties</a></dfn>. When you want to define a new
vocabulary, or ontology, you define new classes of things and new properties.
When you say what type of thing something is, you say a <dfn><a id="Class"
name="Class">Class</a></dfn> it belongs to.</p>

<p>The property which tells you what type something is is
<code>rdf:type</code> which can be abbreviated to N3 to just <code>a</code>.
So we can define a class of person</p>
<br />
<br />

<pre>:Person a rdfs:Class.
</pre>
<br />
<br />


<p>In the same document, we could introduce an actual person</p>
<pre>:Pat a :Person.
</pre>

<p>Classes just tell you about the thing which is in them. An object can be
in many classes. There doesn't have to be any hierarchical relationship --
think of Person, AnimateObject, Animal, TallPerson, Friend, and so on. If
there is a relationship between two classes you can state it - check out the
properties (of classes) in RDF Schema and the the <a
href="http://www.daml.org/">DAML ontology</a> vocabularies.</p>
<pre>:Woman a rdfs:Class; rdfs:subClassOf :Person .
</pre>
<br />
<br />


<p>A property is something which is used to declare a relationship between
two things.</p>
<pre>:sister a rdf:Property.
</pre>

<p>Sometimes when a relationship exists between two things, you immediately
know something about them, which you can express as a class. When the subject
of any property must be in a class, that class is a <dfn><a name="domain"
id="domain">domain</a></dfn> of the property. When the object must be in a
class, that class is called the <dfn><a name="range"
id="range">range</a></dfn> of a property. A property can have many domains
and ranges, but typically one specifies one.</p>
<pre>:sister rdfs:domain :Person; rdfs:range :Woman.
</pre>

<p>Note the class identifiers start with capitals and properties with lower
case letters. This is not a rule, but it is a good convention to stick to.
Note also that because the domain of rdfs:range and rdfs:domain themselves is
rdf:Property, it follows that :sister is a rdf:Property without it being
stated explicitly.</p>

<h4>Equivalence</h4>

<p>Often, you define a vocabulary where one or more of the terms, whether or
not you realized it when you started, is in fact exactly the same as one in
another vocabulary. This is a really useful titbit of information for any
machine or person dealing with the information! The property of equivalence
between two terms is so useful and fundamental that N3 has a special
shorthand for it, "=".</p>
<pre>:Woman = foo:FemaleAdult .
:Title a rdf:Property; = dc:title .
</pre>

<p>Tip: Use other people's vocabularies when you can - it helps interchange
of data. When you define your own vocabulary which includes synonyms, do
record the equivalence because this, likewise, will help present and future
processors process your and others' data in meaningful ways.</p>

<h4>Choosing a namespace and publishing a schema</h4>

<p>A document which defines properties and classes is called a schema. It
defines the meaning of identifiers in a particular namespace. The namespace
URI can be anything which you control: which you can guarantee no one will
reuse for something else. One way is just to send an email about the
namespace. Then look at the headers, and find the <code>Message-Id:</code>
header which gives the unique identifier he mailer created for the mail
message, and use that. Another way is to put a document in a bit of very well
maintained web space which no one can take away from you. Or of course if you
are just playing with it, use a file (say <code>mydb.n3</code>) in the same
directory as the rest of your work, and the namespace identifier you can use
is just &lt;<code>mydb.n3#&gt;</code>.</p>

<p>When use a web document to contain information in N3 about the terms you
define (good practice!) then the namespace will end in a hash.</p>

<p>You don't have to make your schema available to the world, but it helps
machine process documents written with your vocabulary if you do. It
especially helps if the email message or web page is written in RDF (in XML
or in N3) and contains the schema information, as a program can associate the
two easily, if it finds the mail or looks up the web page. If you do this,
the namespace will be the document URI followed by a <code>#.</code></p>

<p>This is a big topic - see for example further reading</p>
<ul>
  <li>W3C Namespace policy</li>
  <li>W3C draft persistence policy</li>
  <li><a href="/Provider/Style/URI">Cool URIs don't change</a></li>
</ul>

<p>Now you know all you need to start creating your own vocabularies, or
ontologies, and you have pointers to where to look for the richer ways of
defining them.You don't have to go any further, as what you have now will
allow you to create new applications, and create schemas, data files, and
programs which interchange and manipulate data for the semantic web.</p>
<hr />

<h2>Formulae</h2>

<p>The schemas you write, and the data files you (or your programs) write are
all simple sets of RDF statements. They can all be drawn as simple circle and
arrow diagrams.</p>

<p>Let's call a set of RDF statements a <dfn><a id="context"
name="context">formula</a></dfn>. The formula a statement is in is its
<dfn>context</dfn>. In a formula,</p>
<ul>
  <li>The statements are all independent, in that you can remove any of the
    statements and the rest are still true</li>
  <li>The order of the statements does not in fact matter.</li>
  <li>There is no such thing as the same statement occurring twice any more
    than you can be a person twice.</li>
</ul>

<p>Sometimes, we need to talk about more than one formula. For example, if
either one statement or another is true, then we can't put them in the same
formula.</p>

<p>In N3 a formula can be represented by enclosing all the statements it
encloses in curly braces { } .</p>
<pre>&lt;x.rdf&gt; :says {  :pat a :Person . } .
</pre>

<p>The formula in braces acts just like an identifier in the rest of the
syntax. It is like a literal expression in that it is defined only by its
contents. This example just declares that the document <code>x.rdf</code>
expresses the hypothetical formula in which it is stated that pat is a
person: the statement above doesn't state that pat is a person. (There is a
problem with the XML serialization of this.)</p>

<p>The main reason I can think of for writing formulae is for writing
rules.</p>

<h2>Rules</h2>

<p>A rule tells of a conclusion which one can draw from a premise. A rule is
just a statement of the form that some engine is programmed to process. For
the simplest sort of rule, all you need is one property:
<code>log:implies</code>. (One engine which is programmed to process this is
<a href="Overview.html">cwm</a>. Another is Euler.). The namespace for the
logical and rather experimental things which we introduce now are as in</p>
<pre>@prefix log: &lt;http://www.w3.org/2000/10/swap/log#&gt; .
</pre>

<p>A simple rule, then, is,</p>
<br />
<br />

<pre>{ sensor:thermostat  math:greaterThan "30" . } log:implies { control:furnace control:setTo "1" . } .
</pre>

<p>If a system is built which understands all the parts, this would allow it,
give</p>
<pre>sensor:thermostat  math:greaterThan "30" .
</pre>

<p>to conclude</p>
<pre>control:furnace control:setTo "1".
</pre>

<p>This rule is simple and useful, but in practice them more powerful rules
can be applied to any identifiers. We nee a way of saying this. A given
formula is true even if the given identifier is replaced -- consistently
throughout the context -- with any other identifier. This is represented by a
magic "log:forAll" property of the formula.</p>
<pre>this log:forAll :x, :y.
{:x :parent :y} log:implies {:y :child :x}.
</pre>

<p>Read this something like: "This is true for any values of x and y. If x is
the parent of y then y is the child of x." The <em>this</em> refers to the
formula whose {braces} immediately enclosing it - or as in this case the
formula expressed by the document if at the outer level.</p>

<p>In fact you can use an ontology property to declare that parent and child
are inverse.</p>
<pre>:parent ont:inverse :child .
</pre>

<p>A machine can then infer the same thing given a generic rule</p>
<pre>this log:forAll :p, :q .

{  :p ont:inverse :q . } log:implies

  { this log:forAll :x, :y.
      { :x :p :y. } log:implies { :y :q :x. }
  } .
</pre>

<p>The outer rule is that if p is the inverse of q, then the inside rule is a
true one. The inner rule is that if x is the p of y, then y is the q x. The
inner rule applies equally to any x and y. The whole thing applies to any p
and q. Once the main rule has been written once, then the property "inverse"
can be used instead of writing the specific rule each time.</p>

<p>I haven't said anything about what machine would execute them when. I
expect there will be many different engines which make those decisions
differently. Check the documentation of software near you.</p>

<p>One program I hacked together is called <em>cwm</em>, (pronounced as in
the welsh word with a short "oo"). Further examples will use that.</p>
<br />
<br />


<h2>Query/Filter</h2>
<address>
  added by reagle 20020408
</address>

<p>Now that we know how to make a statements in N3, what can we do with them?
One thing we can do is use them to obtain other useful information via a
query/filter.</p>

<p>In <a href="test/uncle.n3">uncle.n3</a> we state that Fred is the father
Joe, and Bob is the brother of Fred; we also describe the logical rule for
the uncle relationship:</p>
<pre>@prefix : &lt;uncle#&gt;.
:Fred is :father of :Joe.
:Bob is :brother of :Fred.

@prefix log: &lt;http://www.w3.org/2000/10/swap/log#&gt; .
this log:forAll :who1, :who2.
{ :who1 :father [ :brother :who2 ] } log:implies { :who1 :uncle :who2 }.
</pre>

<p>This rule means "whenever someone's father has a brother, then the latter
is their uncle". This rule, once is cwm's store, will cause <em><a
href="doc/cwm.html">cwm</a></em> to conclude the deduce the uncle information
when it runs with the command line option <code>--think.</code></p>

<p>In another file (<a href="test/uncleF.n3">uncleF.n3</a>) we use as a
<em>filter</em>. When a filter runs (unlike --think) only the information
gathered by the rules is preserved. We use a filter to select the logical
relationships that we want from the mass of what is already known:</p>
<pre>@prefix : &lt;uncle#&gt;.
@prefix log: &lt;http://www.w3.org/2000/10/swap/log#&gt; .

this log:forAll :p.

# What is the relationship between Joe and Bob

{ :Joe :p :Bob } log:implies { :p a :RelationshipBetweeJoeAndBob }.

# Is Bob an Uncle of Joe?

{ :Joe :uncle :Bob } log:implies { :Joe :uncle :Bob }.
</pre>

<p>When we ask cwm to consider the implication it concludes:</p>
<pre>&gt; python cwm.py uncle.n3 --think --filter=uncleF.n3
    :Joe     :uncle :Bob .
    :uncle     a :RelationshipBetweeJoeAndBob .
</pre>

<p>You can read the command line as <em>read uncle.n3 and the deduce any new
information you can given any rules you have. Now just tell me the
information selected by the filter uncleF.n3</em>.</p>

<h3>More</h3>

<p>At this point, you should be getting the hang of it and be writing stuff.
To give you some more ideas, though, there is a <a href="Examples">longer
list of more complex and varied examples</a>. These come with less tutorial
explanation.</p>

<p>Have fun!</p>
<hr />

<h2>Glossary</h2>

<p>These are not formal definitions - just phrases to help you get the hang
of what these things mean. The definition terms are linked back to more
information where available.</p>
<dl>
  <dt><a href="#Class" name="Class1" id="Class1">Class</a></dt>
    <dd>A set of <a href="#Thing">Things</a>; a one-parameter predicate; a
      unary relation.</dd>
  <dt><a name="Domain" id="Domain" href="#domain">domain</a></dt>
    <dd>For a <a href="#Property">Property</a>, a class of things which any
      subject of the <a href="#Property">Property</a> must be in.</dd>
  <dt><a href="#context" name="Formula" id="Formula">Formula</a></dt>
    <dd>An (unordered) set of <a href="#Statement">statements</a>. You can
      write one out in N3 using {braces}.</dd>
  <dt><a name="context1" id="context1">context</a></dt>
    <dd>The relationship between a statement and a formula containing it.</dd>
  <dt><a href="doc/cwm" name="cwm" id="cwm">cwm</a></dt>
    <dd>(From: Closed world machine; valley.) A bit of code for playing with
      this stuff, as grep is for regular expressions. Sucks in RDF in XML or
      N3, processes rules, and spits it out again.</dd>
  <dt><a name="filter" id="filter">filter</a></dt>
    <dd>A set of <a href="#rule">rules</a> which are used to select certain
      data from a larger amount of information.</dd>
  <dt><a name="N3" id="N3" href="/DesignIssues/Notation3">N3</a></dt>
    <dd>Notation3, a quick notation for jotting down or reading RDF semantic
      web information, and experimenting with more advanced sematic web
      features.</dd>
  <dt><a name="object" id="object" href="#L553">object</a></dt>
    <dd>Of the three parts of a statement, the object is one of the two
      things related by the predicate. Often, it is the value of some
      property, such as the color of a car. See also: subject, predicate.</dd>
  <dt><a name="predicate" id="predicate">predicate</a></dt>
    <dd>Of the three parts of a statement, the predicate, or verb, is the
      resource, specifically the Property, which defines what the statement
      means. See also: subject, object.</dd>
  <dt><a href="#Properties" name="Property" id="Property">Property</a></dt>
    <dd>A sort of relationship between two things; a binary relation. A
      Property can be used as the <a href="#predicate">predicate</a> in a <a
      href="#Statement">statement</a>.</dd>
  <dt><a name="range1" id="range1" href="#range">range</a></dt>
    <dd>For a <a href="#Property">Property</a>, its range is a class which
      any <a href="#object">object</a> of that <a
      href="#Property">Property</a> must be in.</dd>
  <dt><a name="rule" id="rule">rule</a></dt>
    <dd>A loose term for a Statement that an engine has been programmed to
      process. Different engines have different sets of rules. <a
      href="#cwm">cwm</a> rules are <a href="#Statement">statements</a> whose
      verb is <code>log:implies</code>.</dd>
  <dt><a name="Resource" id="Resource">Resource</a></dt>
    <dd>That identified by a Universal Resource Identifier (without a "#").
      If the URI starts "http:", then the resource is some form of generic
      document.</dd>
  <dt><a name="Statement" id="Statement">Statement</a></dt>
    <dd>A subject, predicate and object which assert meaning defined by the
      particular predicate used.</dd>
  <dt><a name="subject" id="subject">subject</a></dt>
    <dd>Of the three parts of a statement, the subject is one of the two
      things related by the predicate. Often, it indicates the thing being
      described, such as a car whos color and length are being given. See
      also: object, predicate</dd>
  <dt><a name="Thing" id="Thing">Thing</a></dt>
    <dd>In DAML, a generic name for anything - abstract, animate, inanimate,
      whatever. The class which anything is in. (In RDF parlance,
      confusingly, rdf:Resource.) Identified by a URI with or without a "#"
      in it.</dd>
  <dt><a name="Truth" id="Truth">Truth</a></dt>
    <dd>In the log: namespace, a Class of all formulae which are true.</dd>
  <dt><a name="type" id="type">type</a></dt>
    <dd>A particular property used to assert that a thing is in a certain
      Class. The relationship between a thing and any Class it is in.</dd>
  <dt><a name="URI" id="URI">URI</a></dt>
    <dd>Universal Resource Identifier. The way of identifying anything
      (including Classes, Properties or individual things of any sort). Not
      everything has a URI, as you can talk about something by just using its
      properties. But using a URI allows other documents and systems to
      easily reuse your information.</dd>
</dl>

<h2 id="References">References</h2>
<ul>
  <li><a href="Examples.html">Many More Examples</a></li>
  <li><a href="/DesignIssues/Notation3.html">Notation3 - Design Issues
    article</a></li>
</ul>
<br />
<br />

<hr />
<br />
<br />


<p>Tim BL, with his director hat off</p>

<p>$Id$</p>
</body>
</html>
